Result for running Dominion test suit:
unittest1.c:
Starting tests for updateCoins()...

Treasure cards: 0
Bonus: 1

TEST: Coin Count - copper
Actual: 1
Expected: 1
PASSED

TEST: Coin Count - silver
Actual: 1
Expected: 1
PASSED

TEST: Coin Count - gold
Actual: 1
Expected: 1
PASSED


Treasure cards: 5
Bonus: 3

TEST: Coin Count - copper
Actual: 8
Expected: 8
PASSED

TEST: Coin Count - silver
Actual: 13
Expected: 13
PASSED

TEST: Coin Count - gold
Actual: 18
Expected: 18
PASSED

TESTS SUCCESSFULLY COMPLETED

File 'dominion.c'
Lines executed:52.59% of 656
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:254
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    23767:    9:  if (*(int*)a > *(int*)b)
     4441:   10:    return 1;
    19326:   11:  if (*(int*)a < *(int*)b)
     8134:   12:    return -1;
    11192:   13:  return 0;
    23767:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      283:   44:  SelectStream(1);
      283:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
      566:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      283:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     6226:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    62260:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    53770:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    28300:   65:        }
     2830:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      283:   73:  if (numPlayers == 2)
        -:   74:    {
      283:   75:      state->supplyCount[curse] = 10;
      283:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      283:   87:  if (numPlayers == 2)
        -:   88:    {
      283:   89:      state->supplyCount[estate] = 8;
      283:   90:      state->supplyCount[duchy] = 8;
      283:   91:      state->supplyCount[province] = 8;
      283:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      283:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      283:  102:  state->supplyCount[silver] = 40;
      283:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    11886:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    93390:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    43865:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     5410:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
      533:  115:		  if (numPlayers == 2){ 
      533:  116:		    state->supplyCount[i] = 8; 
      533:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
      533:  119:		}
        -:  120:	      else
        -:  121:		{
     2297:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     2830:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    41035:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    41035:  130:	}
        -:  131:
     5660:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     1698:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
      566:  140:      state->deckCount[i] = 0;
     4528:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
     1698:  143:	  state->deck[i][j] = estate;
     1698:  144:	  state->deckCount[i]++;
     1698:  145:	}
     9056:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
     3962:  148:	  state->deck[i][j] = copper;
     3962:  149:	  state->deckCount[i]++;		
     3962:  150:	}
      566:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     1698:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
      566:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
      566:  160:    }
        -:  161:
        -:  162:  //draw player hands
     1698:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      566:  166:      state->handCount[i] = 0;
      566:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
      566:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    15848:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
     7641:  178:      state->embargoTokens[i] = 0;
     7641:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      283:  182:  state->outpostPlayed = 0;
      283:  183:  state->phase = 0;
      283:  184:  state->numActions = 1;
      283:  185:  state->numBuys = 1;
      283:  186:  state->playedCardCount = 0;
      283:  187:  state->whoseTurn = 0;
      283:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     3396:  192:  for (it = 0; it < 5; it++){
     1415:  193:    drawCard(state->whoseTurn, state);
     1415:  194:  }
        -:  195:
      283:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
      283:  198:  return 0;
      283:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     1137:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     1137:  209:  if (state->deckCount[player] < 1)
       70:  210:    return -1;
     1067:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    28426:  214:  while (state->deckCount[player] > 0) {
    13146:  215:    card = floor(Random() * state->deckCount[player]);
    13146:  216:    newDeck[newDeckPos] = state->deck[player][card];
    13146:  217:    newDeckPos++;
   116860:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    45284:  219:      state->deck[player][i] = state->deck[player][i+1];
    45284:  220:    }
    13146:  221:    state->deckCount[player]--;
        -:  222:  }
    28426:  223:  for (i = 0; i < newDeckPos; i++) {
    13146:  224:    state->deck[player][i] = newDeck[i];
    13146:  225:    state->deckCount[player]++;
    13146:  226:  }
        -:  227:
     1067:  228:  return 0;
     1137:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
     1466:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
     1466:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
     1466:  243:  if ( state->numActions < 1 )
        -:  244:    {
     1217:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
      249:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
      494:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
        4:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
      245:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
      245:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
      245:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
      245:  269:  return 0;
     1466:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
     1139:  280:  who = state->whoseTurn;
        -:  281:
     1139:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
     1139:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
     1139:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
     1139:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
     1139:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  298:  
     1139:  299:    state->coins = (state->coins) - (getCost(supplyPos));
     1139:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
     1139:  308:  return 0;
     1139:  309:}
        -:  310:
        -:  311:int numHandCards(struct gameState *state) {
     8955:  312:  return state->handCount[ whoseTurn(state) ];
        -:  313:}
        -:  314:
        -:  315:int handCard(int handPos, struct gameState *state) {
    18023:  316:  int currentPlayer = whoseTurn(state);
    18023:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
        -:  320:int supplyCount(int card, struct gameState *state) {
     2434:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
        -:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
    #####:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
    #####:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
    #####:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
        -:  346:int whoseTurn(struct gameState *state) {
    29649:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
        -:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
     1160:  353:  int currentPlayer = whoseTurn(state);
        -:  354:  
        -:  355:  //Discard hand
    14970:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
     6325:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     6325:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
     6325:  359:  }
     1160:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
     1160:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
      588:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
      588:  365:  }
        -:  366:  else{
      572:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
     1160:  370:  state->outpostPlayed = 0;
     1160:  371:  state->phase = 0;
     1160:  372:  state->numActions = 1;
     1160:  373:  state->coins = 0;
     1160:  374:  state->numBuys = 1;
     1160:  375:  state->playedCardCount = 0;
     1160:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    13920:  380:  for (k = 0; k < 5; k++){
     5800:  381:    drawCard(state->whoseTurn, state);//Draw a card
     5800:  382:  }
        -:  383:
        -:  384:  //Update money
     1160:  385:  updateCoins(state->whoseTurn, state , 0);
        -:  386:
     1160:  387:  return 0;
        -:  388:}
        -:  389:
        -:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
     1312:  395:  if (state->supplyCount[province] == 0)
        -:  396:    {
       72:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
     1240:  401:  j = 0;
    64480:  402:  for (i = 0; i < 25; i++)
        -:  403:    {
    31000:  404:      if (state->supplyCount[i] == 0)
        -:  405:	{
      120:  406:	  j++;
      120:  407:	}
    31000:  408:    }
     1240:  409:  if ( j >= 3)
        -:  410:    {
       40:  411:      return 1;
        -:  412:    }
        -:  413:
     1200:  414:  return 0;
     1312:  415:}
        -:  416:
        -:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
       64:  420:  int score = 0;
        -:  421:  //score from hand
      448:  422:  for (i = 0; i < state->handCount[player]; i++)
        -:  423:    {
      160:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
      180:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
      160:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
      177:  427:      if (state->hand[player][i] == province) { score = score + 6; };
      160:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
      160:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      160:  430:    }
        -:  431:
        -:  432:  //score from discard
     1398:  433:  for (i = 0; i < state->discardCount[player]; i++)
        -:  434:    {
      635:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
      702:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
      635:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
      752:  438:      if (state->discard[player][i] == province) { score = score + 6; };
      635:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
      635:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  441:    }
        -:  442:
        -:  443:  //score from deck
     1398:  444:  for (i = 0; i < state->discardCount[player]; i++)
        -:  445:    {
      670:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
      691:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
      635:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
      719:  449:      if (state->deck[player][i] == province) { score = score + 6; };
      635:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
      635:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  452:    }
        -:  453:
       64:  454:  return score;
        -:  455:}
        -:  456:
        -:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
        -:  468:	{
    #####:  469:	  players[i] = -9999;
    #####:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
        -:  474:	}
    #####:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
        -:  482:	{
    #####:  483:	  j = i;
    #####:  484:	}
    #####:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
        -:  493:	{
    #####:  494:	  players[i]++;
    #####:  495:	}
    #####:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
        -:  503:	{
    #####:  504:	  j = i;
    #####:  505:	}
    #####:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
        -:  513:	{
    #####:  514:	  players[i] = 1;
    #####:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
    #####:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
        -:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     8215:  528:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    14786:  533:    for (i = 0; i < state->discardCount[player];i++){
     6946:  534:      state->deck[player][i] = state->discard[player][i];
     6946:  535:      state->discard[player][i] = -1;
     6946:  536:    }
        -:  537:
      447:  538:    state->deckCount[player] = state->discardCount[player];
      447:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
      447:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
      447:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
      447:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
      447:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
      447:  559:    if (deckCounter == 0)
    #####:  560:      return -1;
        -:  561:
      447:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      447:  563:    state->deckCount[player]--;
      447:  564:    state->handCount[player]++;//Increment hand count
      447:  565:  }
        -:  566:
        -:  567:  else{
     7768:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     7768:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     7768:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     7768:  576:    state->deckCount[player]--;
     7768:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     8215:  580:  return 0;
     8215:  581:}
        -:  582:
        -:  583:int getCost(int cardNumber)
        -:  584:{
     2306:  585:  switch( cardNumber ) 
        -:  586:    {
        -:  587:    case curse:
       10:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
      512:  594:      return 8;
        -:  595:    case copper:
       14:  596:      return 0;
        -:  597:    case silver:
      888:  598:      return 3;
        -:  599:    case gold:
      626:  600:      return 6;
        -:  601:    case adventurer:
      128:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
      128:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
     2306:  644:}
        -:  645:
        -:  646:
        -:  647:void adventurerEffect(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand[], int z)
        -:  648:{
     1646:  649:  while(drawntreasure<=2){
      611:  650:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
       30:  651:	  shuffle(currentPlayer, state);
       30:  652:	}
      611:  653:	drawCard(currentPlayer, state);
      611:  654:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     1074:  655:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
      494:  656:	  drawntreasure++;
        -:  657:	else{
      117:  658:	  temphand[z]=cardDrawn;
      117:  659:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
      117:  660:	  z++;
        -:  661:	}
        -:  662:      }
      658:  663:      while(z-1>=0){
      117:  664:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
      117:  665:	z=z-1;
        -:  666:      }
      212:  667:}
        -:  668:
        -:  669:void smithyEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  670:{
        -:  671:  //+3 Cards
      672:  672:      for (int i = 1; i < 3; i++)
        -:  673:	{
      244:  674:	  drawCard(currentPlayer, state);
      244:  675:	}
        -:  676:			
        -:  677:      //discard card from hand
       92:  678:      discardCard(handPos, currentPlayer, state, 0);
       92:  679:}
        -:  680:
        -:  681:void councilRoomEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  682:{
        -:  683:  //+4 Cards
      260:  684:      for (int i = 0; i < 4; i++)
        -:  685:	{
      104:  686:	  drawCard(currentPlayer, state);
      104:  687:	}
        -:  688:			
        -:  689:      //+1 Buy
       26:  690:      state->numBuys++;
        -:  691:			
        -:  692:      //Each other player draws a card
      156:  693:      for (int i = 0; i < state->numPlayers; i++)
        -:  694:	{
       52:  695:	  if ( i == currentPlayer )
        -:  696:	    {
       26:  697:	      drawCard(i, state);
       26:  698:	    }
       52:  699:	}
        -:  700:			
        -:  701:      //put played card in played card pile
       26:  702:      discardCard(handPos, currentPlayer, state, 0);
       26:  703:}
        -:  704:
        -:  705:void feastEffect(struct gameState *state, int currentPlayer, int temphand[], int choice1, int x)
        -:  706:{
        -:  707:  //gain card with cost up to 5
        -:  708:      //Backup hand
    #####:  709:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  710:	      temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  711:	      state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  712:      }
        -:  713:      //Backup hand
        -:  714:
        -:  715:      //Update Coins for Buy
    #####:  716:      updateCoins(currentPlayer, state, 5);
    #####:  717:      x = 1;//Condition to loop on
    #####:  718:      while( x == 1) {//Buy one card
    #####:  719:	      if (supplyCount(choice1, state) <= 0){
        -:  720:	        if (DEBUG)
        -:  721:	          printf("None of that card left, sorry!\n");
        -:  722:
        -:  723:	        if (DEBUG){
        -:  724:	          printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  725:	        }
    #####:  726:	      }
    #####:  727:	      else if (state->coins < getCost(choice1)){
    #####:  728:	        printf("That card is too expensive!\n");
        -:  729:
        -:  730:	        if (DEBUG){
        -:  731:	          printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  732:	        }
    #####:  733:	      }
        -:  734:	      else{
        -:  735:
        -:  736:	        if (DEBUG){
        -:  737:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  738:	        }
        -:  739:
    #####:  740:	        gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  741:	        x = 0;//No more buying cards
        -:  742:
        -:  743:	        if (DEBUG){
        -:  744:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  745:	        }
        -:  746:
        -:  747:	      }
        -:  748:      }     
        -:  749:
        -:  750:      //Reset Hand
    #####:  751:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  752:	      state->hand[currentPlayer][i] = temphand[i];
    #####:  753:	      temphand[i] = -1;
    #####:  754:      }
    #####:  755:}
        -:  756:
        -:  757:int mineEffect(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int j)
        -:  758:{
       14:  759:  int result = 0;
       14:  760:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  761:
       28:  762:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  763:	    {
    #####:  764:        result = -1;
        -:  765:	      //return -1;
    #####:  766:	    }
        -:  767:		
       28:  768:      if (choice2 > treasure_map || choice2 < curse)
        -:  769:	    {
    #####:  770:        result = -1;
        -:  771:	      //return -1;
    #####:  772:	    }
        -:  773:
       14:  774:      if ( (getCost(state->hand[currentPlayer][choice1]) + 4) > getCost(choice2) )
        -:  775:	    {
       14:  776:        result = -1;
        -:  777:	      //return -1;
       14:  778:	    }
        -:  779:
       14:  780:      gainCard(choice2, state, 2, currentPlayer);
        -:  781:
        -:  782:      //discard card from hand
       14:  783:      discardCard(handPos, currentPlayer, state, 0);
        -:  784:
        -:  785:      //discard trashed card
       56:  786:      for (int i = 0; i < state->handCount[currentPlayer]; i++)
        -:  787:	    {
       28:  788:	      if (state->hand[currentPlayer][i] == j)
        -:  789:	      {
       14:  790:	        discardCard(i, currentPlayer, state, 0);			
       14:  791:	        break;
        -:  792:	      }
       14:  793:	    }
        -:  794:			
       14:  795:      return result;
        -:  796:}
        -:  797:
        -:  798:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  799:{
        -:  800:  int i;
14397326483292946558:  801:  int j = 0;
        -:  802:  int k;
14397326483292946558:  803:  int x = 0;
        -:  804:  int index;
        -:  805:  int result;
14397326483292946558:  806:  int currentPlayer = whoseTurn(state);
14397326483292946558:  807:  int nextPlayer = currentPlayer + 1;
        -:  808:
14397326483292946558:  809:  int tributeRevealedCards[2] = {-1, -1};
        -:  810:  int temphand[MAX_HAND];// moved above the if statement
14397326483292946558:  811:  int drawntreasure=0;
14397326483292946558:  812:  int cardDrawn=0;
14397326483292946558:  813:  int z = 0;// this is the counter for the temp hand
14397326483292946558:  814:  if (nextPlayer > (state->numPlayers - 1)){
  6582881:  815:    nextPlayer = 0;
  6582881:  816:  }
        -:  817:  
        -:  818:	
        -:  819:  //uses switch to select card and perform actions
3352292577943071121:  820:  switch( card ) 
        -:  821:    {
        -:  822:    case adventurer:
474366694532:  823:      adventurerEffect(drawntreasure, state, currentPlayer, cardDrawn, temphand, z);
474366694532:  824:      return 0;
        -:  825:			
        -:  826:    case council_room:
72057594037927962:  827:      councilRoomEffect(state, currentPlayer, handPos);
72057594037927962:  828:      return 0;
        -:  829:			
        -:  830:    case feast:
68719476743:  831:      feastEffect(state, currentPlayer, temphand, choice1,x);
68719476743:  832:      return 0;
        -:  833:			
        -:  834:    case gardens:
17424526879:  835:      return -1;
        -:  836:			
        -:  837:    case mine:
7738139929303872884:  838:      result = mineEffect(state, currentPlayer, choice1, choice2, handPos, j);
7738139929303872884:  839:      return result;
        -:  840:			
        -:  841:    case remodel:
72058094107324227:  842:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  843:
72058094107324227:  844:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  845:	{
73014444037:  846:	  return -1;
        -:  847:	}
        -:  848:
9172086132:  849:      gainCard(choice2, state, 0, currentPlayer);
        -:  850:
        -:  851:      //discard card from hand
9172086132:  852:      discardCard(handPos, currentPlayer, state, 0);
        -:  853:
        -:  854:      //discard trashed card
103145724687375321:  855:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  856:	{
93224767193:  857:	  if (state->hand[currentPlayer][i] == j)
        -:  858:	    {
8525144140093551465:  859:	      discardCard(i, currentPlayer, state, 0);			
8525144140093551465:  860:	      break;
        -:  861:	    }
    29285:  862:	}
        -:  863:
        -:  864:
6217793866309828627:  865:      return 0;
        -:  866:		
        -:  867:    case smithy:
8245918788311056415:  868:      smithyEffect(state, currentPlayer, handPos);
8245918788311056415:  869:      return 0;
        -:  870:		
        -:  871:    case village:
        -:  872:      //+1 Card
1919895156:  873:      drawCard(currentPlayer, state);
        -:  874:			
        -:  875:      //+2 Actions
1919895156:  876:      state->numActions = state->numActions + 2;
        -:  877:			
        -:  878:      //discard played card from hand
1919895156:  879:      discardCard(handPos, currentPlayer, state, 0);
1919895156:  880:      return 0;
        -:  881:		
        -:  882:    case baron:
72057679937273862:  883:      state->numBuys++;//Increase buys by 1!
72057679937273862:  884:      if (choice1 > 0){//Boolean true or going to discard an estate
16919086439:  885:	int p = 0;//Iterator for hand!
16919086439:  886:	int card_not_discarded = 1;//Flag for discard set!
7308900660905877056:  887:	while(card_not_discarded){
14700501649139433493:  888:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
7166187310294237187:  889:	    state->coins += 4;//Add 4 coins to the amount of coins
7166187310294237187:  890:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
7166187310294237187:  891:	    state->discardCount[currentPlayer]++;
7194460570033353316:  892:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  893:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  894:	    }
    #####:  895:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  896:	    state->handCount[currentPlayer]--;
    #####:  897:	    card_not_discarded = 0;//Exit the loop
    #####:  898:	  }
    #####:  899:	  else if (p > state->handCount[currentPlayer]){
        -:  900:	    if(DEBUG) {
        -:  901:	      printf("No estate cards in your hand, invalid choice\n");
        -:  902:	      printf("Must gain an estate if there are any\n");
        -:  903:	    }
    #####:  904:	    if (supplyCount(estate, state) > 0){
    #####:  905:	      gainCard(estate, state, 0, currentPlayer);
    #####:  906:	      state->supplyCount[estate]--;//Decrement estates
    #####:  907:	      if (supplyCount(estate, state) == 0){
    #####:  908:		isGameOver(state);
    #####:  909:	      }
    #####:  910:	    }
    #####:  911:	    card_not_discarded = 0;//Exit the loop
    #####:  912:	  }
        -:  913:			    
        -:  914:	  else{
    #####:  915:	    p++;//Next card
        -:  916:	  }
        -:  917:	}
    #####:  918:      }
        -:  919:			    
        -:  920:      else{
    #####:  921:	if (supplyCount(estate, state) > 0){
    #####:  922:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  923:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  924:	  if (supplyCount(estate, state) == 0){
    #####:  925:	    isGameOver(state);
    #####:  926:	  }
    #####:  927:	}
        -:  928:      }
        -:  929:	    
        -:  930:      
    #####:  931:      return 0;
        -:  932:		
        -:  933:    case great_hall:
        -:  934:      //+1 Card
    #####:  935:      drawCard(currentPlayer, state);
        -:  936:			
        -:  937:      //+1 Actions
    #####:  938:      state->numActions++;
        -:  939:			
        -:  940:      //discard card from hand
    #####:  941:      discardCard(handPos, currentPlayer, state, 0);
    #####:  942:      return 0;
        -:  943:		
        -:  944:    case minion:
        -:  945:      //+1 action
    #####:  946:      state->numActions++;
        -:  947:			
        -:  948:      //discard card from hand
    #####:  949:      discardCard(handPos, currentPlayer, state, 0);
        -:  950:			
    #####:  951:      if (choice1)		//+2 coins
        -:  952:	{
    #####:  953:	  state->coins = state->coins + 2;
    #####:  954:	}
        -:  955:			
    #####:  956:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  957:	{
        -:  958:	  //discard hand
    #####:  959:	  while(numHandCards(state) > 0)
        -:  960:	    {
    #####:  961:	      discardCard(handPos, currentPlayer, state, 0);
        -:  962:	    }
        -:  963:				
        -:  964:	  //draw 4
    #####:  965:	  for (i = 0; i < 4; i++)
        -:  966:	    {
    #####:  967:	      drawCard(currentPlayer, state);
    #####:  968:	    }
        -:  969:				
        -:  970:	  //other players discard hand and redraw if hand size > 4
    #####:  971:	  for (i = 0; i < state->numPlayers; i++)
        -:  972:	    {
    #####:  973:	      if (i != currentPlayer)
        -:  974:		{
    #####:  975:		  if ( state->handCount[i] > 4 )
        -:  976:		    {
        -:  977:		      //discard hand
    #####:  978:		      while( state->handCount[i] > 0 )
        -:  979:			{
    #####:  980:			  discardCard(handPos, i, state, 0);
        -:  981:			}
        -:  982:							
        -:  983:		      //draw 4
    #####:  984:		      for (j = 0; j < 4; j++)
        -:  985:			{
    #####:  986:			  drawCard(i, state);
    #####:  987:			}
    #####:  988:		    }
    #####:  989:		}
    #####:  990:	    }
        -:  991:				
    #####:  992:	}
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case steward:
    #####:  996:      if (choice1 == 1)
        -:  997:	{
        -:  998:	  //+2 cards
    #####:  999:	  drawCard(currentPlayer, state);
    #####: 1000:	  drawCard(currentPlayer, state);
    #####: 1001:	}
    #####: 1002:      else if (choice1 == 2)
        -: 1003:	{
        -: 1004:	  //+2 coins
    #####: 1005:	  state->coins = state->coins + 2;
    #####: 1006:	}
        -: 1007:      else
        -: 1008:	{
        -: 1009:	  //trash 2 cards in hand
    #####: 1010:	  discardCard(choice2, currentPlayer, state, 1);
    #####: 1011:	  discardCard(choice3, currentPlayer, state, 1);
        -: 1012:	}
        -: 1013:			
        -: 1014:      //discard card from hand
    #####: 1015:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1016:      return 0;
        -: 1017:		
        -: 1018:    case tribute:
    #####: 1019:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1020:	if (state->deckCount[nextPlayer] > 0){
    #####: 1021:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1022:	  state->deckCount[nextPlayer]--;
    #####: 1023:	}
    #####: 1024:	else if (state->discardCount[nextPlayer] > 0){
    #####: 1025:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1026:	  state->discardCount[nextPlayer]--;
    #####: 1027:	}
        -: 1028:	else{
        -: 1029:	  //No Card to Reveal
        -: 1030:	  if (DEBUG){
        -: 1031:	    printf("No cards to reveal\n");
        -: 1032:	  }
        -: 1033:	}
    #####: 1034:      }
        -: 1035:	    
        -: 1036:      else{
    #####: 1037:	if (state->deckCount[nextPlayer] == 0){
    #####: 1038:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1039:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1040:	    state->deckCount[nextPlayer]++;
    #####: 1041:	    state->discard[nextPlayer][i] = -1;
    #####: 1042:	    state->discardCount[nextPlayer]--;
    #####: 1043:	  }
        -: 1044:			    
    #####: 1045:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####: 1046:	} 
    #####: 1047:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1048:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1049:	state->deckCount[nextPlayer]--;
    #####: 1050:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
        -: 1053:      }    
        -: 1054:		       
    #####: 1055:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1056:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1057:	state->playedCardCount++;
    #####: 1058:	tributeRevealedCards[1] = -1;
    #####: 1059:      }
        -: 1060:
    #####: 1061:      for (i = 0; i <= 2; i ++){
    #####: 1062:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1063:	  state->coins += 2;
    #####: 1064:	}
        -: 1065:		    
    #####: 1066:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1067:	  drawCard(currentPlayer, state);
    #####: 1068:	  drawCard(currentPlayer, state);
    #####: 1069:	}
        -: 1070:	else{//Action Card
    #####: 1071:	  state->numActions = state->numActions + 2;
        -: 1072:	}
    #####: 1073:      }
        -: 1074:	    
    #####: 1075:      return 0;
        -: 1076:		
        -: 1077:    case ambassador:
    #####: 1078:      j = 0;		//used to check if player has enough cards to discard
        -: 1079:
    #####: 1080:      if (choice2 > 2 || choice2 < 0)
        -: 1081:	{
    #####: 1082:	  return -1;				
        -: 1083:	}
        -: 1084:
    #####: 1085:      if (choice1 == handPos)
        -: 1086:	{
    #####: 1087:	  return -1;
        -: 1088:	}
        -: 1089:
    #####: 1090:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1091:	{
    #####: 1092:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1093:	    {
    #####: 1094:	      j++;
    #####: 1095:	    }
    #####: 1096:	}
    #####: 1097:      if (j < choice2)
        -: 1098:	{
    #####: 1099:	  return -1;				
        -: 1100:	}
        -: 1101:
        -: 1102:      if (DEBUG) 
        -: 1103:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1104:
        -: 1105:      //increase supply count for choosen card by amount being discarded
    #####: 1106:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1107:			
        -: 1108:      //each other player gains a copy of revealed card
    #####: 1109:      for (i = 0; i < state->numPlayers; i++)
        -: 1110:	{
    #####: 1111:	  if (i != currentPlayer)
        -: 1112:	    {
    #####: 1113:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1114:	    }
    #####: 1115:	}
        -: 1116:
        -: 1117:      //discard played card from hand
    #####: 1118:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1119:
        -: 1120:      //trash copies of cards returned to supply
    #####: 1121:      for (j = 0; j < choice2; j++)
        -: 1122:	{
    #####: 1123:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1124:	    {
    #####: 1125:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1126:		{
    #####: 1127:		  discardCard(i, currentPlayer, state, 1);
    #####: 1128:		  break;
        -: 1129:		}
    #####: 1130:	    }
    #####: 1131:	}			
        -: 1132:
    #####: 1133:      return 0;
        -: 1134:		
        -: 1135:    case cutpurse:
        -: 1136:
    #####: 1137:      updateCoins(currentPlayer, state, 2);
    #####: 1138:      for (i = 0; i < state->numPlayers; i++)
        -: 1139:	{
    #####: 1140:	  if (i != currentPlayer)
        -: 1141:	    {
    #####: 1142:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1143:		{
    #####: 1144:		  if (state->hand[i][j] == copper)
        -: 1145:		    {
    #####: 1146:		      discardCard(j, i, state, 0);
    #####: 1147:		      break;
        -: 1148:		    }
    #####: 1149:		  if (j == state->handCount[i])
        -: 1150:		    {
    #####: 1151:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1152:			{
        -: 1153:			  if (DEBUG)
        -: 1154:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1155:			}	
    #####: 1156:		      break;
        -: 1157:		    }		
    #####: 1158:		}
        -: 1159:					
    #####: 1160:	    }
        -: 1161:				
    #####: 1162:	}				
        -: 1163:
        -: 1164:      //discard played card from hand
    #####: 1165:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1166:
    #####: 1167:      return 0;
        -: 1168:
        -: 1169:		
        -: 1170:    case embargo: 
        -: 1171:      //+2 Coins
    #####: 1172:      state->coins = state->coins + 2;
        -: 1173:			
        -: 1174:      //see if selected pile is in play
    #####: 1175:      if ( state->supplyCount[choice1] == -1 )
        -: 1176:	{
    #####: 1177:	  return -1;
        -: 1178:	}
        -: 1179:			
        -: 1180:      //add embargo token to selected supply pile
    #####: 1181:      state->embargoTokens[choice1]++;
        -: 1182:			
        -: 1183:      //trash card
    #####: 1184:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1185:      return 0;
        -: 1186:		
        -: 1187:    case outpost:
        -: 1188:      //set outpost flag
    #####: 1189:      state->outpostPlayed++;
        -: 1190:			
        -: 1191:      //discard card
    #####: 1192:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1193:      return 0;
        -: 1194:		
        -: 1195:    case salvager:
        -: 1196:      //+1 buy
    #####: 1197:      state->numBuys++;
        -: 1198:			
    #####: 1199:      if (choice1)
        -: 1200:	{
        -: 1201:	  //gain coins equal to trashed card
    #####: 1202:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1203:	  //trash card
    #####: 1204:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1205:	}
        -: 1206:			
        -: 1207:      //discard card
    #####: 1208:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1209:      return 0;
        -: 1210:		
        -: 1211:    case sea_hag:
    #####: 1212:      for (i = 0; i < state->numPlayers; i++){
    #####: 1213:	if (i != currentPlayer){
    #####: 1214:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1215:	  state->discardCount[i]++;
    #####: 1216:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1217:	}
    #####: 1218:      }
    #####: 1219:      return 0;
        -: 1220:		
        -: 1221:    case treasure_map:
        -: 1222:      //search hand for another treasure_map
    #####: 1223:      index = -1;
    #####: 1224:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1225:	{
    #####: 1226:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1227:	    {
    #####: 1228:	      index = i;
    #####: 1229:	      break;
        -: 1230:	    }
    #####: 1231:	}
    #####: 1232:      if (index > -1)
        -: 1233:	{
        -: 1234:	  //trash both treasure cards
    #####: 1235:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1236:	  discardCard(index, currentPlayer, state, 1);
        -: 1237:
        -: 1238:	  //gain 4 Gold cards
    #####: 1239:	  for (i = 0; i < 4; i++)
        -: 1240:	    {
    #####: 1241:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1242:	    }
        -: 1243:				
        -: 1244:	  //return success
    #####: 1245:	  return 1;
        -: 1246:	}
        -: 1247:			
        -: 1248:      //no second treasure_map found in hand
    #####: 1249:      return -1;
        -: 1250:    }
        -: 1251:	
    #####: 1252:  return -1;
      359: 1253:}
        -: 1254:
        -: 1255:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1256:{
        -: 1257:	
        -: 1258:  //if card is not trashed, added to Played pile 
      161: 1259:  if (trashFlag < 1)
        -: 1260:    {
        -: 1261:      //add card to played pile
      161: 1262:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      161: 1263:      state->playedCardCount++;
      161: 1264:    }
        -: 1265:	
        -: 1266:  //set played card to -1
      161: 1267:  state->hand[currentPlayer][handPos] = -1;
        -: 1268:	
        -: 1269:  //remove card from player's hand
      161: 1270:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1271:    {
        -: 1272:      //reduce number of cards in hand
    #####: 1273:      state->handCount[currentPlayer]--;
    #####: 1274:    }
      161: 1275:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1276:    {
        -: 1277:      //reduce number of cards in hand
    #####: 1278:      state->handCount[currentPlayer]--;
    #####: 1279:    }
        -: 1280:  else 	
        -: 1281:    {
        -: 1282:      //replace discarded card with last card in hand
      161: 1283:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1284:      //set last card to -1
      161: 1285:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1286:      //reduce number of cards in hand
      161: 1287:      state->handCount[currentPlayer]--;
        -: 1288:    }
        -: 1289:	
      161: 1290:  return 0;
        -: 1291:}
        -: 1292:
        -: 1293:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1294:{
        -: 1295:  //Note: supplyPos is enum of choosen card
        -: 1296:	
        -: 1297:  //check if supply pile is empty (0) or card is not used in game (-1)
     1295: 1298:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1299:    {
       38: 1300:      return -1;
        -: 1301:    }
        -: 1302:	
        -: 1303:  //added card for [whoseTurn] current player:
        -: 1304:  // toFlag = 0 : add to discard
        -: 1305:  // toFlag = 1 : add to deck
        -: 1306:  // toFlag = 2 : add to hand
        -: 1307:
     1257: 1308:  if (toFlag == 1)
        -: 1309:    {
       26: 1310:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
       26: 1311:      state->deckCount[player]++;
       26: 1312:    }
     1231: 1313:  else if (toFlag == 2)
        -: 1314:    {
       40: 1315:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
       40: 1316:      state->handCount[player]++;
       40: 1317:    }
        -: 1318:  else
        -: 1319:    {
     1191: 1320:      state->discard[player][ state->discardCount[player] ] = supplyPos;
     1191: 1321:      state->discardCount[player]++;
        -: 1322:    }
        -: 1323:	
        -: 1324:  //decrease number in supply pile
     1257: 1325:  state->supplyCount[supplyPos]--;
        -: 1326:	 
     1257: 1327:  return 0;
     1295: 1328:}
        -: 1329:
        -: 1330:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1331:{
        -: 1332:  int i;
        -: 1333:	
        -: 1334:  //reset coin count
     1856: 1335:  state->coins = 0;
        -: 1336:
        -: 1337:  //add coins for each Treasure card in player's hand
    22482: 1338:  for (i = 0; i < state->handCount[player]; i++)
        -: 1339:    {
     9385: 1340:      if (state->hand[player][i] == copper)
        -: 1341:	{
     4437: 1342:	  state->coins += 1;
     4437: 1343:	}
     4948: 1344:      else if (state->hand[player][i] == silver)
        -: 1345:	{
     1835: 1346:	  state->coins += 2;
     1835: 1347:	}
     3113: 1348:      else if (state->hand[player][i] == gold)
        -: 1349:	{
      605: 1350:	  state->coins += 3;
      605: 1351:	}	
     9385: 1352:    }	
        -: 1353:
        -: 1354:  //add bonus
     1856: 1355:  state->coins += bonus;
        -: 1356:
     1856: 1357:  return 0;
        -: 1358:}
        -: 1359:
        -: 1360:
        -: 1361://end of dominion.c
        -: 1362:
unittest2.c:
Starting tests for isGameOver()...

TEST: Province cards empty
Actual: 1
Expected: 1
PASSED

TEST: Three supply piles empty
Actual: 1
Expected: 1
PASSED

TEST: Province cards not empty

TEST: Three supply piles not empty
Actual: 0
Expected: 0
PASSED

TESTS SUCCESSFULLY COMPLETED

File 'unittest2.c'
Lines executed:85.37% of 41
unittest2.c:creating 'unittest2.c.gcov'

File 'dominion.c'
Lines executed:52.59% of 656
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:255
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    23795:    9:  if (*(int*)a > *(int*)b)
     4441:   10:    return 1;
    19354:   11:  if (*(int*)a < *(int*)b)
     8144:   12:    return -1;
    11210:   13:  return 0;
    23795:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      284:   44:  SelectStream(1);
      284:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
      568:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      284:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     6248:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    62480:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    53960:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    28400:   65:        }
     2840:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      284:   73:  if (numPlayers == 2)
        -:   74:    {
      284:   75:      state->supplyCount[curse] = 10;
      284:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      284:   87:  if (numPlayers == 2)
        -:   88:    {
      284:   89:      state->supplyCount[estate] = 8;
      284:   90:      state->supplyCount[duchy] = 8;
      284:   91:      state->supplyCount[province] = 8;
      284:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      284:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      284:  102:  state->supplyCount[silver] = 40;
      284:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    11928:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    93720:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    44020:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     5429:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
      535:  115:		  if (numPlayers == 2){ 
      535:  116:		    state->supplyCount[i] = 8; 
      535:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
      535:  119:		}
        -:  120:	      else
        -:  121:		{
     2305:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     2840:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    41180:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    41180:  130:	}
        -:  131:
     5680:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     1704:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
      568:  140:      state->deckCount[i] = 0;
     4544:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
     1704:  143:	  state->deck[i][j] = estate;
     1704:  144:	  state->deckCount[i]++;
     1704:  145:	}
     9088:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
     3976:  148:	  state->deck[i][j] = copper;
     3976:  149:	  state->deckCount[i]++;		
     3976:  150:	}
      568:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     1704:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
      568:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
      568:  160:    }
        -:  161:
        -:  162:  //draw player hands
     1704:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      568:  166:      state->handCount[i] = 0;
      568:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
      568:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    15904:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
     7668:  178:      state->embargoTokens[i] = 0;
     7668:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      284:  182:  state->outpostPlayed = 0;
      284:  183:  state->phase = 0;
      284:  184:  state->numActions = 1;
      284:  185:  state->numBuys = 1;
      284:  186:  state->playedCardCount = 0;
      284:  187:  state->whoseTurn = 0;
      284:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     3408:  192:  for (it = 0; it < 5; it++){
     1420:  193:    drawCard(state->whoseTurn, state);
     1420:  194:  }
        -:  195:
      284:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
      284:  198:  return 0;
      284:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     1139:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     1139:  209:  if (state->deckCount[player] < 1)
       70:  210:    return -1;
     1069:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    28470:  214:  while (state->deckCount[player] > 0) {
    13166:  215:    card = floor(Random() * state->deckCount[player]);
    13166:  216:    newDeck[newDeckPos] = state->deck[player][card];
    13166:  217:    newDeckPos++;
   117012:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    45340:  219:      state->deck[player][i] = state->deck[player][i+1];
    45340:  220:    }
    13166:  221:    state->deckCount[player]--;
        -:  222:  }
    28470:  223:  for (i = 0; i < newDeckPos; i++) {
    13166:  224:    state->deck[player][i] = newDeck[i];
    13166:  225:    state->deckCount[player]++;
    13166:  226:  }
        -:  227:
     1069:  228:  return 0;
     1139:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
     1466:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
     1466:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
     1466:  243:  if ( state->numActions < 1 )
        -:  244:    {
     1217:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
      249:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
      494:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
        4:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
      245:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
      245:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
      245:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
      245:  269:  return 0;
     1466:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
     1139:  280:  who = state->whoseTurn;
        -:  281:
     1139:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
     1139:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
     1139:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
     1139:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
     1139:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  298:  
     1139:  299:    state->coins = (state->coins) - (getCost(supplyPos));
     1139:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
     1139:  308:  return 0;
     1139:  309:}
        -:  310:
        -:  311:int numHandCards(struct gameState *state) {
     8955:  312:  return state->handCount[ whoseTurn(state) ];
        -:  313:}
        -:  314:
        -:  315:int handCard(int handPos, struct gameState *state) {
    18023:  316:  int currentPlayer = whoseTurn(state);
    18023:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
        -:  320:int supplyCount(int card, struct gameState *state) {
     2434:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
        -:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
    #####:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
    #####:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
    #####:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
        -:  346:int whoseTurn(struct gameState *state) {
    29649:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
        -:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
     1160:  353:  int currentPlayer = whoseTurn(state);
        -:  354:  
        -:  355:  //Discard hand
    14970:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
     6325:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     6325:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
     6325:  359:  }
     1160:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
     1160:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
      588:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
      588:  365:  }
        -:  366:  else{
      572:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
     1160:  370:  state->outpostPlayed = 0;
     1160:  371:  state->phase = 0;
     1160:  372:  state->numActions = 1;
     1160:  373:  state->coins = 0;
     1160:  374:  state->numBuys = 1;
     1160:  375:  state->playedCardCount = 0;
     1160:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    13920:  380:  for (k = 0; k < 5; k++){
     5800:  381:    drawCard(state->whoseTurn, state);//Draw a card
     5800:  382:  }
        -:  383:
        -:  384:  //Update money
     1160:  385:  updateCoins(state->whoseTurn, state , 0);
        -:  386:
     1160:  387:  return 0;
        -:  388:}
        -:  389:
        -:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
     1318:  395:  if (state->supplyCount[province] == 0)
        -:  396:    {
       74:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
     1244:  401:  j = 0;
    64688:  402:  for (i = 0; i < 25; i++)
        -:  403:    {
    31100:  404:      if (state->supplyCount[i] == 0)
        -:  405:	{
      126:  406:	  j++;
      126:  407:	}
    31100:  408:    }
     1244:  409:  if ( j >= 3)
        -:  410:    {
       42:  411:      return 1;
        -:  412:    }
        -:  413:
     1202:  414:  return 0;
     1318:  415:}
        -:  416:
        -:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
       64:  420:  int score = 0;
        -:  421:  //score from hand
      448:  422:  for (i = 0; i < state->handCount[player]; i++)
        -:  423:    {
      160:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
      180:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
      160:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
      177:  427:      if (state->hand[player][i] == province) { score = score + 6; };
      160:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
      160:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      160:  430:    }
        -:  431:
        -:  432:  //score from discard
     1398:  433:  for (i = 0; i < state->discardCount[player]; i++)
        -:  434:    {
      635:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
      702:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
      635:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
      752:  438:      if (state->discard[player][i] == province) { score = score + 6; };
      635:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
      635:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  441:    }
        -:  442:
        -:  443:  //score from deck
     1398:  444:  for (i = 0; i < state->discardCount[player]; i++)
        -:  445:    {
      670:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
      691:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
      635:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
      719:  449:      if (state->deck[player][i] == province) { score = score + 6; };
      635:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
      635:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  452:    }
        -:  453:
       64:  454:  return score;
        -:  455:}
        -:  456:
        -:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
        -:  468:	{
    #####:  469:	  players[i] = -9999;
    #####:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
        -:  474:	}
    #####:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
        -:  482:	{
    #####:  483:	  j = i;
    #####:  484:	}
    #####:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
        -:  493:	{
    #####:  494:	  players[i]++;
    #####:  495:	}
    #####:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
        -:  503:	{
    #####:  504:	  j = i;
    #####:  505:	}
    #####:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
        -:  513:	{
    #####:  514:	  players[i] = 1;
    #####:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
    #####:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
        -:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     8220:  528:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    14786:  533:    for (i = 0; i < state->discardCount[player];i++){
     6946:  534:      state->deck[player][i] = state->discard[player][i];
     6946:  535:      state->discard[player][i] = -1;
     6946:  536:    }
        -:  537:
      447:  538:    state->deckCount[player] = state->discardCount[player];
      447:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
      447:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
      447:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
      447:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
      447:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
      447:  559:    if (deckCounter == 0)
    #####:  560:      return -1;
        -:  561:
      447:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      447:  563:    state->deckCount[player]--;
      447:  564:    state->handCount[player]++;//Increment hand count
      447:  565:  }
        -:  566:
        -:  567:  else{
     7773:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     7773:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     7773:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     7773:  576:    state->deckCount[player]--;
     7773:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     8220:  580:  return 0;
     8220:  581:}
        -:  582:
        -:  583:int getCost(int cardNumber)
        -:  584:{
     2306:  585:  switch( cardNumber ) 
        -:  586:    {
        -:  587:    case curse:
       10:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
      512:  594:      return 8;
        -:  595:    case copper:
       14:  596:      return 0;
        -:  597:    case silver:
      888:  598:      return 3;
        -:  599:    case gold:
      626:  600:      return 6;
        -:  601:    case adventurer:
      128:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
      128:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
     2306:  644:}
        -:  645:
        -:  646:
        -:  647:void adventurerEffect(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand[], int z)
        -:  648:{
     1646:  649:  while(drawntreasure<=2){
      611:  650:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
       30:  651:	  shuffle(currentPlayer, state);
       30:  652:	}
      611:  653:	drawCard(currentPlayer, state);
      611:  654:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     1074:  655:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
      494:  656:	  drawntreasure++;
        -:  657:	else{
      117:  658:	  temphand[z]=cardDrawn;
      117:  659:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
      117:  660:	  z++;
        -:  661:	}
        -:  662:      }
      658:  663:      while(z-1>=0){
      117:  664:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
      117:  665:	z=z-1;
        -:  666:      }
      212:  667:}
        -:  668:
        -:  669:void smithyEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  670:{
        -:  671:  //+3 Cards
      672:  672:      for (int i = 1; i < 3; i++)
        -:  673:	{
      244:  674:	  drawCard(currentPlayer, state);
      244:  675:	}
        -:  676:			
        -:  677:      //discard card from hand
       92:  678:      discardCard(handPos, currentPlayer, state, 0);
       92:  679:}
        -:  680:
        -:  681:void councilRoomEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  682:{
        -:  683:  //+4 Cards
      260:  684:      for (int i = 0; i < 4; i++)
        -:  685:	{
      104:  686:	  drawCard(currentPlayer, state);
      104:  687:	}
        -:  688:			
        -:  689:      //+1 Buy
       26:  690:      state->numBuys++;
        -:  691:			
        -:  692:      //Each other player draws a card
      156:  693:      for (int i = 0; i < state->numPlayers; i++)
        -:  694:	{
       52:  695:	  if ( i == currentPlayer )
        -:  696:	    {
       26:  697:	      drawCard(i, state);
       26:  698:	    }
       52:  699:	}
        -:  700:			
        -:  701:      //put played card in played card pile
       26:  702:      discardCard(handPos, currentPlayer, state, 0);
       26:  703:}
        -:  704:
        -:  705:void feastEffect(struct gameState *state, int currentPlayer, int temphand[], int choice1, int x)
        -:  706:{
        -:  707:  //gain card with cost up to 5
        -:  708:      //Backup hand
    #####:  709:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  710:	      temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  711:	      state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  712:      }
        -:  713:      //Backup hand
        -:  714:
        -:  715:      //Update Coins for Buy
    #####:  716:      updateCoins(currentPlayer, state, 5);
    #####:  717:      x = 1;//Condition to loop on
    #####:  718:      while( x == 1) {//Buy one card
    #####:  719:	      if (supplyCount(choice1, state) <= 0){
        -:  720:	        if (DEBUG)
        -:  721:	          printf("None of that card left, sorry!\n");
        -:  722:
        -:  723:	        if (DEBUG){
        -:  724:	          printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  725:	        }
    #####:  726:	      }
    #####:  727:	      else if (state->coins < getCost(choice1)){
    #####:  728:	        printf("That card is too expensive!\n");
        -:  729:
        -:  730:	        if (DEBUG){
        -:  731:	          printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  732:	        }
    #####:  733:	      }
        -:  734:	      else{
        -:  735:
        -:  736:	        if (DEBUG){
        -:  737:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  738:	        }
        -:  739:
    #####:  740:	        gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  741:	        x = 0;//No more buying cards
        -:  742:
        -:  743:	        if (DEBUG){
        -:  744:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  745:	        }
        -:  746:
        -:  747:	      }
        -:  748:      }     
        -:  749:
        -:  750:      //Reset Hand
    #####:  751:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  752:	      state->hand[currentPlayer][i] = temphand[i];
    #####:  753:	      temphand[i] = -1;
    #####:  754:      }
    #####:  755:}
        -:  756:
        -:  757:int mineEffect(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int j)
        -:  758:{
       14:  759:  int result = 0;
       14:  760:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  761:
       28:  762:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  763:	    {
    #####:  764:        result = -1;
        -:  765:	      //return -1;
    #####:  766:	    }
        -:  767:		
       28:  768:      if (choice2 > treasure_map || choice2 < curse)
        -:  769:	    {
    #####:  770:        result = -1;
        -:  771:	      //return -1;
    #####:  772:	    }
        -:  773:
       14:  774:      if ( (getCost(state->hand[currentPlayer][choice1]) + 4) > getCost(choice2) )
        -:  775:	    {
       14:  776:        result = -1;
        -:  777:	      //return -1;
       14:  778:	    }
        -:  779:
       14:  780:      gainCard(choice2, state, 2, currentPlayer);
        -:  781:
        -:  782:      //discard card from hand
       14:  783:      discardCard(handPos, currentPlayer, state, 0);
        -:  784:
        -:  785:      //discard trashed card
       56:  786:      for (int i = 0; i < state->handCount[currentPlayer]; i++)
        -:  787:	    {
       28:  788:	      if (state->hand[currentPlayer][i] == j)
        -:  789:	      {
       14:  790:	        discardCard(i, currentPlayer, state, 0);			
       14:  791:	        break;
        -:  792:	      }
       14:  793:	    }
        -:  794:			
       14:  795:      return result;
        -:  796:}
        -:  797:
        -:  798:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  799:{
        -:  800:  int i;
14397326483292946558:  801:  int j = 0;
        -:  802:  int k;
14397326483292946558:  803:  int x = 0;
        -:  804:  int index;
        -:  805:  int result;
14397326483292946558:  806:  int currentPlayer = whoseTurn(state);
14397326483292946558:  807:  int nextPlayer = currentPlayer + 1;
        -:  808:
14397326483292946558:  809:  int tributeRevealedCards[2] = {-1, -1};
        -:  810:  int temphand[MAX_HAND];// moved above the if statement
14397326483292946558:  811:  int drawntreasure=0;
14397326483292946558:  812:  int cardDrawn=0;
14397326483292946558:  813:  int z = 0;// this is the counter for the temp hand
14397326483292946558:  814:  if (nextPlayer > (state->numPlayers - 1)){
  6582881:  815:    nextPlayer = 0;
  6582881:  816:  }
        -:  817:  
        -:  818:	
        -:  819:  //uses switch to select card and perform actions
3352292577943071121:  820:  switch( card ) 
        -:  821:    {
        -:  822:    case adventurer:
474366694532:  823:      adventurerEffect(drawntreasure, state, currentPlayer, cardDrawn, temphand, z);
474366694532:  824:      return 0;
        -:  825:			
        -:  826:    case council_room:
72057594037927962:  827:      councilRoomEffect(state, currentPlayer, handPos);
72057594037927962:  828:      return 0;
        -:  829:			
        -:  830:    case feast:
68719476743:  831:      feastEffect(state, currentPlayer, temphand, choice1,x);
68719476743:  832:      return 0;
        -:  833:			
        -:  834:    case gardens:
17424526879:  835:      return -1;
        -:  836:			
        -:  837:    case mine:
7738139929303872884:  838:      result = mineEffect(state, currentPlayer, choice1, choice2, handPos, j);
7738139929303872884:  839:      return result;
        -:  840:			
        -:  841:    case remodel:
72058094107324227:  842:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  843:
72058094107324227:  844:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  845:	{
73014444037:  846:	  return -1;
        -:  847:	}
        -:  848:
9172086132:  849:      gainCard(choice2, state, 0, currentPlayer);
        -:  850:
        -:  851:      //discard card from hand
9172086132:  852:      discardCard(handPos, currentPlayer, state, 0);
        -:  853:
        -:  854:      //discard trashed card
103145724687375321:  855:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  856:	{
93224767193:  857:	  if (state->hand[currentPlayer][i] == j)
        -:  858:	    {
8525144140093551465:  859:	      discardCard(i, currentPlayer, state, 0);			
8525144140093551465:  860:	      break;
        -:  861:	    }
    29285:  862:	}
        -:  863:
        -:  864:
6217793866309828627:  865:      return 0;
        -:  866:		
        -:  867:    case smithy:
8245918788311056415:  868:      smithyEffect(state, currentPlayer, handPos);
8245918788311056415:  869:      return 0;
        -:  870:		
        -:  871:    case village:
        -:  872:      //+1 Card
1919895156:  873:      drawCard(currentPlayer, state);
        -:  874:			
        -:  875:      //+2 Actions
1919895156:  876:      state->numActions = state->numActions + 2;
        -:  877:			
        -:  878:      //discard played card from hand
1919895156:  879:      discardCard(handPos, currentPlayer, state, 0);
1919895156:  880:      return 0;
        -:  881:		
        -:  882:    case baron:
72057679937273862:  883:      state->numBuys++;//Increase buys by 1!
72057679937273862:  884:      if (choice1 > 0){//Boolean true or going to discard an estate
16919086439:  885:	int p = 0;//Iterator for hand!
16919086439:  886:	int card_not_discarded = 1;//Flag for discard set!
7308900660905877056:  887:	while(card_not_discarded){
14700501649139433493:  888:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
7166187310294237187:  889:	    state->coins += 4;//Add 4 coins to the amount of coins
7166187310294237187:  890:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
7166187310294237187:  891:	    state->discardCount[currentPlayer]++;
7194460570033353316:  892:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  893:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  894:	    }
    #####:  895:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  896:	    state->handCount[currentPlayer]--;
    #####:  897:	    card_not_discarded = 0;//Exit the loop
    #####:  898:	  }
    #####:  899:	  else if (p > state->handCount[currentPlayer]){
        -:  900:	    if(DEBUG) {
        -:  901:	      printf("No estate cards in your hand, invalid choice\n");
        -:  902:	      printf("Must gain an estate if there are any\n");
        -:  903:	    }
    #####:  904:	    if (supplyCount(estate, state) > 0){
    #####:  905:	      gainCard(estate, state, 0, currentPlayer);
    #####:  906:	      state->supplyCount[estate]--;//Decrement estates
    #####:  907:	      if (supplyCount(estate, state) == 0){
    #####:  908:		isGameOver(state);
    #####:  909:	      }
    #####:  910:	    }
    #####:  911:	    card_not_discarded = 0;//Exit the loop
    #####:  912:	  }
        -:  913:			    
        -:  914:	  else{
    #####:  915:	    p++;//Next card
        -:  916:	  }
        -:  917:	}
    #####:  918:      }
        -:  919:			    
        -:  920:      else{
    #####:  921:	if (supplyCount(estate, state) > 0){
    #####:  922:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  923:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  924:	  if (supplyCount(estate, state) == 0){
    #####:  925:	    isGameOver(state);
    #####:  926:	  }
    #####:  927:	}
        -:  928:      }
        -:  929:	    
        -:  930:      
    #####:  931:      return 0;
        -:  932:		
        -:  933:    case great_hall:
        -:  934:      //+1 Card
    #####:  935:      drawCard(currentPlayer, state);
        -:  936:			
        -:  937:      //+1 Actions
    #####:  938:      state->numActions++;
        -:  939:			
        -:  940:      //discard card from hand
    #####:  941:      discardCard(handPos, currentPlayer, state, 0);
    #####:  942:      return 0;
        -:  943:		
        -:  944:    case minion:
        -:  945:      //+1 action
    #####:  946:      state->numActions++;
        -:  947:			
        -:  948:      //discard card from hand
    #####:  949:      discardCard(handPos, currentPlayer, state, 0);
        -:  950:			
    #####:  951:      if (choice1)		//+2 coins
        -:  952:	{
    #####:  953:	  state->coins = state->coins + 2;
    #####:  954:	}
        -:  955:			
    #####:  956:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  957:	{
        -:  958:	  //discard hand
    #####:  959:	  while(numHandCards(state) > 0)
        -:  960:	    {
    #####:  961:	      discardCard(handPos, currentPlayer, state, 0);
        -:  962:	    }
        -:  963:				
        -:  964:	  //draw 4
    #####:  965:	  for (i = 0; i < 4; i++)
        -:  966:	    {
    #####:  967:	      drawCard(currentPlayer, state);
    #####:  968:	    }
        -:  969:				
        -:  970:	  //other players discard hand and redraw if hand size > 4
    #####:  971:	  for (i = 0; i < state->numPlayers; i++)
        -:  972:	    {
    #####:  973:	      if (i != currentPlayer)
        -:  974:		{
    #####:  975:		  if ( state->handCount[i] > 4 )
        -:  976:		    {
        -:  977:		      //discard hand
    #####:  978:		      while( state->handCount[i] > 0 )
        -:  979:			{
    #####:  980:			  discardCard(handPos, i, state, 0);
        -:  981:			}
        -:  982:							
        -:  983:		      //draw 4
    #####:  984:		      for (j = 0; j < 4; j++)
        -:  985:			{
    #####:  986:			  drawCard(i, state);
    #####:  987:			}
    #####:  988:		    }
    #####:  989:		}
    #####:  990:	    }
        -:  991:				
    #####:  992:	}
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case steward:
    #####:  996:      if (choice1 == 1)
        -:  997:	{
        -:  998:	  //+2 cards
    #####:  999:	  drawCard(currentPlayer, state);
    #####: 1000:	  drawCard(currentPlayer, state);
    #####: 1001:	}
    #####: 1002:      else if (choice1 == 2)
        -: 1003:	{
        -: 1004:	  //+2 coins
    #####: 1005:	  state->coins = state->coins + 2;
    #####: 1006:	}
        -: 1007:      else
        -: 1008:	{
        -: 1009:	  //trash 2 cards in hand
    #####: 1010:	  discardCard(choice2, currentPlayer, state, 1);
    #####: 1011:	  discardCard(choice3, currentPlayer, state, 1);
        -: 1012:	}
        -: 1013:			
        -: 1014:      //discard card from hand
    #####: 1015:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1016:      return 0;
        -: 1017:		
        -: 1018:    case tribute:
    #####: 1019:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1020:	if (state->deckCount[nextPlayer] > 0){
    #####: 1021:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1022:	  state->deckCount[nextPlayer]--;
    #####: 1023:	}
    #####: 1024:	else if (state->discardCount[nextPlayer] > 0){
    #####: 1025:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1026:	  state->discardCount[nextPlayer]--;
    #####: 1027:	}
        -: 1028:	else{
        -: 1029:	  //No Card to Reveal
        -: 1030:	  if (DEBUG){
        -: 1031:	    printf("No cards to reveal\n");
        -: 1032:	  }
        -: 1033:	}
    #####: 1034:      }
        -: 1035:	    
        -: 1036:      else{
    #####: 1037:	if (state->deckCount[nextPlayer] == 0){
    #####: 1038:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1039:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1040:	    state->deckCount[nextPlayer]++;
    #####: 1041:	    state->discard[nextPlayer][i] = -1;
    #####: 1042:	    state->discardCount[nextPlayer]--;
    #####: 1043:	  }
        -: 1044:			    
    #####: 1045:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####: 1046:	} 
    #####: 1047:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1048:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1049:	state->deckCount[nextPlayer]--;
    #####: 1050:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
        -: 1053:      }    
        -: 1054:		       
    #####: 1055:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1056:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1057:	state->playedCardCount++;
    #####: 1058:	tributeRevealedCards[1] = -1;
    #####: 1059:      }
        -: 1060:
    #####: 1061:      for (i = 0; i <= 2; i ++){
    #####: 1062:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1063:	  state->coins += 2;
    #####: 1064:	}
        -: 1065:		    
    #####: 1066:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1067:	  drawCard(currentPlayer, state);
    #####: 1068:	  drawCard(currentPlayer, state);
    #####: 1069:	}
        -: 1070:	else{//Action Card
    #####: 1071:	  state->numActions = state->numActions + 2;
        -: 1072:	}
    #####: 1073:      }
        -: 1074:	    
    #####: 1075:      return 0;
        -: 1076:		
        -: 1077:    case ambassador:
    #####: 1078:      j = 0;		//used to check if player has enough cards to discard
        -: 1079:
    #####: 1080:      if (choice2 > 2 || choice2 < 0)
        -: 1081:	{
    #####: 1082:	  return -1;				
        -: 1083:	}
        -: 1084:
    #####: 1085:      if (choice1 == handPos)
        -: 1086:	{
    #####: 1087:	  return -1;
        -: 1088:	}
        -: 1089:
    #####: 1090:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1091:	{
    #####: 1092:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1093:	    {
    #####: 1094:	      j++;
    #####: 1095:	    }
    #####: 1096:	}
    #####: 1097:      if (j < choice2)
        -: 1098:	{
    #####: 1099:	  return -1;				
        -: 1100:	}
        -: 1101:
        -: 1102:      if (DEBUG) 
        -: 1103:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1104:
        -: 1105:      //increase supply count for choosen card by amount being discarded
    #####: 1106:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1107:			
        -: 1108:      //each other player gains a copy of revealed card
    #####: 1109:      for (i = 0; i < state->numPlayers; i++)
        -: 1110:	{
    #####: 1111:	  if (i != currentPlayer)
        -: 1112:	    {
    #####: 1113:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1114:	    }
    #####: 1115:	}
        -: 1116:
        -: 1117:      //discard played card from hand
    #####: 1118:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1119:
        -: 1120:      //trash copies of cards returned to supply
    #####: 1121:      for (j = 0; j < choice2; j++)
        -: 1122:	{
    #####: 1123:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1124:	    {
    #####: 1125:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1126:		{
    #####: 1127:		  discardCard(i, currentPlayer, state, 1);
    #####: 1128:		  break;
        -: 1129:		}
    #####: 1130:	    }
    #####: 1131:	}			
        -: 1132:
    #####: 1133:      return 0;
        -: 1134:		
        -: 1135:    case cutpurse:
        -: 1136:
    #####: 1137:      updateCoins(currentPlayer, state, 2);
    #####: 1138:      for (i = 0; i < state->numPlayers; i++)
        -: 1139:	{
    #####: 1140:	  if (i != currentPlayer)
        -: 1141:	    {
    #####: 1142:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1143:		{
    #####: 1144:		  if (state->hand[i][j] == copper)
        -: 1145:		    {
    #####: 1146:		      discardCard(j, i, state, 0);
    #####: 1147:		      break;
        -: 1148:		    }
    #####: 1149:		  if (j == state->handCount[i])
        -: 1150:		    {
    #####: 1151:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1152:			{
        -: 1153:			  if (DEBUG)
        -: 1154:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1155:			}	
    #####: 1156:		      break;
        -: 1157:		    }		
    #####: 1158:		}
        -: 1159:					
    #####: 1160:	    }
        -: 1161:				
    #####: 1162:	}				
        -: 1163:
        -: 1164:      //discard played card from hand
    #####: 1165:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1166:
    #####: 1167:      return 0;
        -: 1168:
        -: 1169:		
        -: 1170:    case embargo: 
        -: 1171:      //+2 Coins
    #####: 1172:      state->coins = state->coins + 2;
        -: 1173:			
        -: 1174:      //see if selected pile is in play
    #####: 1175:      if ( state->supplyCount[choice1] == -1 )
        -: 1176:	{
    #####: 1177:	  return -1;
        -: 1178:	}
        -: 1179:			
        -: 1180:      //add embargo token to selected supply pile
    #####: 1181:      state->embargoTokens[choice1]++;
        -: 1182:			
        -: 1183:      //trash card
    #####: 1184:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1185:      return 0;
        -: 1186:		
        -: 1187:    case outpost:
        -: 1188:      //set outpost flag
    #####: 1189:      state->outpostPlayed++;
        -: 1190:			
        -: 1191:      //discard card
    #####: 1192:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1193:      return 0;
        -: 1194:		
        -: 1195:    case salvager:
        -: 1196:      //+1 buy
    #####: 1197:      state->numBuys++;
        -: 1198:			
    #####: 1199:      if (choice1)
        -: 1200:	{
        -: 1201:	  //gain coins equal to trashed card
    #####: 1202:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1203:	  //trash card
    #####: 1204:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1205:	}
        -: 1206:			
        -: 1207:      //discard card
    #####: 1208:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1209:      return 0;
        -: 1210:		
        -: 1211:    case sea_hag:
    #####: 1212:      for (i = 0; i < state->numPlayers; i++){
    #####: 1213:	if (i != currentPlayer){
    #####: 1214:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1215:	  state->discardCount[i]++;
    #####: 1216:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1217:	}
    #####: 1218:      }
    #####: 1219:      return 0;
        -: 1220:		
        -: 1221:    case treasure_map:
        -: 1222:      //search hand for another treasure_map
    #####: 1223:      index = -1;
    #####: 1224:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1225:	{
    #####: 1226:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1227:	    {
    #####: 1228:	      index = i;
    #####: 1229:	      break;
        -: 1230:	    }
    #####: 1231:	}
    #####: 1232:      if (index > -1)
        -: 1233:	{
        -: 1234:	  //trash both treasure cards
    #####: 1235:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1236:	  discardCard(index, currentPlayer, state, 1);
        -: 1237:
        -: 1238:	  //gain 4 Gold cards
    #####: 1239:	  for (i = 0; i < 4; i++)
        -: 1240:	    {
    #####: 1241:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1242:	    }
        -: 1243:				
        -: 1244:	  //return success
    #####: 1245:	  return 1;
        -: 1246:	}
        -: 1247:			
        -: 1248:      //no second treasure_map found in hand
    #####: 1249:      return -1;
        -: 1250:    }
        -: 1251:	
    #####: 1252:  return -1;
      359: 1253:}
        -: 1254:
        -: 1255:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1256:{
        -: 1257:	
        -: 1258:  //if card is not trashed, added to Played pile 
      161: 1259:  if (trashFlag < 1)
        -: 1260:    {
        -: 1261:      //add card to played pile
      161: 1262:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      161: 1263:      state->playedCardCount++;
      161: 1264:    }
        -: 1265:	
        -: 1266:  //set played card to -1
      161: 1267:  state->hand[currentPlayer][handPos] = -1;
        -: 1268:	
        -: 1269:  //remove card from player's hand
      161: 1270:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1271:    {
        -: 1272:      //reduce number of cards in hand
    #####: 1273:      state->handCount[currentPlayer]--;
    #####: 1274:    }
      161: 1275:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1276:    {
        -: 1277:      //reduce number of cards in hand
    #####: 1278:      state->handCount[currentPlayer]--;
    #####: 1279:    }
        -: 1280:  else 	
        -: 1281:    {
        -: 1282:      //replace discarded card with last card in hand
      161: 1283:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1284:      //set last card to -1
      161: 1285:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1286:      //reduce number of cards in hand
      161: 1287:      state->handCount[currentPlayer]--;
        -: 1288:    }
        -: 1289:	
      161: 1290:  return 0;
        -: 1291:}
        -: 1292:
        -: 1293:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1294:{
        -: 1295:  //Note: supplyPos is enum of choosen card
        -: 1296:	
        -: 1297:  //check if supply pile is empty (0) or card is not used in game (-1)
     1295: 1298:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1299:    {
       38: 1300:      return -1;
        -: 1301:    }
        -: 1302:	
        -: 1303:  //added card for [whoseTurn] current player:
        -: 1304:  // toFlag = 0 : add to discard
        -: 1305:  // toFlag = 1 : add to deck
        -: 1306:  // toFlag = 2 : add to hand
        -: 1307:
     1257: 1308:  if (toFlag == 1)
        -: 1309:    {
       26: 1310:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
       26: 1311:      state->deckCount[player]++;
       26: 1312:    }
     1231: 1313:  else if (toFlag == 2)
        -: 1314:    {
       40: 1315:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
       40: 1316:      state->handCount[player]++;
       40: 1317:    }
        -: 1318:  else
        -: 1319:    {
     1191: 1320:      state->discard[player][ state->discardCount[player] ] = supplyPos;
     1191: 1321:      state->discardCount[player]++;
        -: 1322:    }
        -: 1323:	
        -: 1324:  //decrease number in supply pile
     1257: 1325:  state->supplyCount[supplyPos]--;
        -: 1326:	 
     1257: 1327:  return 0;
     1295: 1328:}
        -: 1329:
        -: 1330:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1331:{
        -: 1332:  int i;
        -: 1333:	
        -: 1334:  //reset coin count
     1857: 1335:  state->coins = 0;
        -: 1336:
        -: 1337:  //add coins for each Treasure card in player's hand
    22494: 1338:  for (i = 0; i < state->handCount[player]; i++)
        -: 1339:    {
     9390: 1340:      if (state->hand[player][i] == copper)
        -: 1341:	{
     4441: 1342:	  state->coins += 1;
     4441: 1343:	}
     4949: 1344:      else if (state->hand[player][i] == silver)
        -: 1345:	{
     1835: 1346:	  state->coins += 2;
     1835: 1347:	}
     3114: 1348:      else if (state->hand[player][i] == gold)
        -: 1349:	{
      605: 1350:	  state->coins += 3;
      605: 1351:	}	
     9390: 1352:    }	
        -: 1353:
        -: 1354:  //add bonus
     1857: 1355:  state->coins += bonus;
        -: 1356:
     1857: 1357:  return 0;
        -: 1358:}
        -: 1359:
        -: 1360:
        -: 1361://end of dominion.c
        -: 1362:
unittest3.c:
Starting tests for shuffle()...

TEST: Player deck count is 0
Actual: -1
Expected: -1
PASSED

TEST: Player deck count is 10 before and after shuffle
Actual: 10
Expected: 10
PASSED

TEST: Cards are shuffled
Actual: 1
Expected: 1
PASSED

TESTS SUCCESSFULLY COMPLETED

File 'unittest3.c'
Lines executed:79.55% of 44
unittest3.c:creating 'unittest3.c.gcov'

File 'dominion.c'
Lines executed:52.59% of 656
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:256
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    23851:    9:  if (*(int*)a > *(int*)b)
     4441:   10:    return 1;
    19410:   11:  if (*(int*)a < *(int*)b)
     8164:   12:    return -1;
    11246:   13:  return 0;
    23851:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      285:   44:  SelectStream(1);
      285:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
      570:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      285:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     6270:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    62700:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    54150:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    28500:   65:        }
     2850:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      285:   73:  if (numPlayers == 2)
        -:   74:    {
      285:   75:      state->supplyCount[curse] = 10;
      285:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      285:   87:  if (numPlayers == 2)
        -:   88:    {
      285:   89:      state->supplyCount[estate] = 8;
      285:   90:      state->supplyCount[duchy] = 8;
      285:   91:      state->supplyCount[province] = 8;
      285:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      285:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      285:  102:  state->supplyCount[silver] = 40;
      285:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    11970:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    94050:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    44175:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     5448:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
      537:  115:		  if (numPlayers == 2){ 
      537:  116:		    state->supplyCount[i] = 8; 
      537:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
      537:  119:		}
        -:  120:	      else
        -:  121:		{
     2313:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     2850:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    41325:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    41325:  130:	}
        -:  131:
     5700:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     1710:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
      570:  140:      state->deckCount[i] = 0;
     4560:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
     1710:  143:	  state->deck[i][j] = estate;
     1710:  144:	  state->deckCount[i]++;
     1710:  145:	}
     9120:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
     3990:  148:	  state->deck[i][j] = copper;
     3990:  149:	  state->deckCount[i]++;		
     3990:  150:	}
      570:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     1710:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
      570:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
      570:  160:    }
        -:  161:
        -:  162:  //draw player hands
     1710:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      570:  166:      state->handCount[i] = 0;
      570:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
      570:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    15960:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
     7695:  178:      state->embargoTokens[i] = 0;
     7695:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      285:  182:  state->outpostPlayed = 0;
      285:  183:  state->phase = 0;
      285:  184:  state->numActions = 1;
      285:  185:  state->numBuys = 1;
      285:  186:  state->playedCardCount = 0;
      285:  187:  state->whoseTurn = 0;
      285:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     3420:  192:  for (it = 0; it < 5; it++){
     1425:  193:    drawCard(state->whoseTurn, state);
     1425:  194:  }
        -:  195:
      285:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
      285:  198:  return 0;
      285:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     1145:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     1145:  209:  if (state->deckCount[player] < 1)
       72:  210:    return -1;
     1073:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    28558:  214:  while (state->deckCount[player] > 0) {
    13206:  215:    card = floor(Random() * state->deckCount[player]);
    13206:  216:    newDeck[newDeckPos] = state->deck[player][card];
    13206:  217:    newDeckPos++;
   117290:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    45439:  219:      state->deck[player][i] = state->deck[player][i+1];
    45439:  220:    }
    13206:  221:    state->deckCount[player]--;
        -:  222:  }
    28558:  223:  for (i = 0; i < newDeckPos; i++) {
    13206:  224:    state->deck[player][i] = newDeck[i];
    13206:  225:    state->deckCount[player]++;
    13206:  226:  }
        -:  227:
     1073:  228:  return 0;
     1145:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
     1466:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
     1466:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
     1466:  243:  if ( state->numActions < 1 )
        -:  244:    {
     1217:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
      249:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
      494:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
        4:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
      245:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
      245:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
      245:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
      245:  269:  return 0;
     1466:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
     1139:  280:  who = state->whoseTurn;
        -:  281:
     1139:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
     1139:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
     1139:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
     1139:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
     1139:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  298:  
     1139:  299:    state->coins = (state->coins) - (getCost(supplyPos));
     1139:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
     1139:  308:  return 0;
     1139:  309:}
        -:  310:
        -:  311:int numHandCards(struct gameState *state) {
     8955:  312:  return state->handCount[ whoseTurn(state) ];
        -:  313:}
        -:  314:
        -:  315:int handCard(int handPos, struct gameState *state) {
    18023:  316:  int currentPlayer = whoseTurn(state);
    18023:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
        -:  320:int supplyCount(int card, struct gameState *state) {
     2434:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
        -:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
    #####:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
    #####:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
    #####:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
        -:  346:int whoseTurn(struct gameState *state) {
    29649:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
        -:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
     1160:  353:  int currentPlayer = whoseTurn(state);
        -:  354:  
        -:  355:  //Discard hand
    14970:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
     6325:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     6325:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
     6325:  359:  }
     1160:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
     1160:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
      588:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
      588:  365:  }
        -:  366:  else{
      572:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
     1160:  370:  state->outpostPlayed = 0;
     1160:  371:  state->phase = 0;
     1160:  372:  state->numActions = 1;
     1160:  373:  state->coins = 0;
     1160:  374:  state->numBuys = 1;
     1160:  375:  state->playedCardCount = 0;
     1160:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    13920:  380:  for (k = 0; k < 5; k++){
     5800:  381:    drawCard(state->whoseTurn, state);//Draw a card
     5800:  382:  }
        -:  383:
        -:  384:  //Update money
     1160:  385:  updateCoins(state->whoseTurn, state , 0);
        -:  386:
     1160:  387:  return 0;
        -:  388:}
        -:  389:
        -:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
     1318:  395:  if (state->supplyCount[province] == 0)
        -:  396:    {
       74:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
     1244:  401:  j = 0;
    64688:  402:  for (i = 0; i < 25; i++)
        -:  403:    {
    31100:  404:      if (state->supplyCount[i] == 0)
        -:  405:	{
      126:  406:	  j++;
      126:  407:	}
    31100:  408:    }
     1244:  409:  if ( j >= 3)
        -:  410:    {
       42:  411:      return 1;
        -:  412:    }
        -:  413:
     1202:  414:  return 0;
     1318:  415:}
        -:  416:
        -:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
       64:  420:  int score = 0;
        -:  421:  //score from hand
      448:  422:  for (i = 0; i < state->handCount[player]; i++)
        -:  423:    {
      160:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
      180:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
      160:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
      177:  427:      if (state->hand[player][i] == province) { score = score + 6; };
      160:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
      160:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      160:  430:    }
        -:  431:
        -:  432:  //score from discard
     1398:  433:  for (i = 0; i < state->discardCount[player]; i++)
        -:  434:    {
      635:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
      702:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
      635:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
      752:  438:      if (state->discard[player][i] == province) { score = score + 6; };
      635:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
      635:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  441:    }
        -:  442:
        -:  443:  //score from deck
     1398:  444:  for (i = 0; i < state->discardCount[player]; i++)
        -:  445:    {
      670:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
      691:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
      635:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
      719:  449:      if (state->deck[player][i] == province) { score = score + 6; };
      635:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
      635:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  452:    }
        -:  453:
       64:  454:  return score;
        -:  455:}
        -:  456:
        -:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
        -:  468:	{
    #####:  469:	  players[i] = -9999;
    #####:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
        -:  474:	}
    #####:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
        -:  482:	{
    #####:  483:	  j = i;
    #####:  484:	}
    #####:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
        -:  493:	{
    #####:  494:	  players[i]++;
    #####:  495:	}
    #####:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
        -:  503:	{
    #####:  504:	  j = i;
    #####:  505:	}
    #####:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
        -:  513:	{
    #####:  514:	  players[i] = 1;
    #####:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
    #####:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
        -:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     8225:  528:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    14786:  533:    for (i = 0; i < state->discardCount[player];i++){
     6946:  534:      state->deck[player][i] = state->discard[player][i];
     6946:  535:      state->discard[player][i] = -1;
     6946:  536:    }
        -:  537:
      447:  538:    state->deckCount[player] = state->discardCount[player];
      447:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
      447:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
      447:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
      447:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
      447:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
      447:  559:    if (deckCounter == 0)
    #####:  560:      return -1;
        -:  561:
      447:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      447:  563:    state->deckCount[player]--;
      447:  564:    state->handCount[player]++;//Increment hand count
      447:  565:  }
        -:  566:
        -:  567:  else{
     7778:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     7778:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     7778:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     7778:  576:    state->deckCount[player]--;
     7778:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     8225:  580:  return 0;
     8225:  581:}
        -:  582:
        -:  583:int getCost(int cardNumber)
        -:  584:{
     2306:  585:  switch( cardNumber ) 
        -:  586:    {
        -:  587:    case curse:
       10:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
      512:  594:      return 8;
        -:  595:    case copper:
       14:  596:      return 0;
        -:  597:    case silver:
      888:  598:      return 3;
        -:  599:    case gold:
      626:  600:      return 6;
        -:  601:    case adventurer:
      128:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
      128:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
     2306:  644:}
        -:  645:
        -:  646:
        -:  647:void adventurerEffect(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand[], int z)
        -:  648:{
     1646:  649:  while(drawntreasure<=2){
      611:  650:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
       30:  651:	  shuffle(currentPlayer, state);
       30:  652:	}
      611:  653:	drawCard(currentPlayer, state);
      611:  654:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     1074:  655:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
      494:  656:	  drawntreasure++;
        -:  657:	else{
      117:  658:	  temphand[z]=cardDrawn;
      117:  659:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
      117:  660:	  z++;
        -:  661:	}
        -:  662:      }
      658:  663:      while(z-1>=0){
      117:  664:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
      117:  665:	z=z-1;
        -:  666:      }
      212:  667:}
        -:  668:
        -:  669:void smithyEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  670:{
        -:  671:  //+3 Cards
      672:  672:      for (int i = 1; i < 3; i++)
        -:  673:	{
      244:  674:	  drawCard(currentPlayer, state);
      244:  675:	}
        -:  676:			
        -:  677:      //discard card from hand
       92:  678:      discardCard(handPos, currentPlayer, state, 0);
       92:  679:}
        -:  680:
        -:  681:void councilRoomEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  682:{
        -:  683:  //+4 Cards
      260:  684:      for (int i = 0; i < 4; i++)
        -:  685:	{
      104:  686:	  drawCard(currentPlayer, state);
      104:  687:	}
        -:  688:			
        -:  689:      //+1 Buy
       26:  690:      state->numBuys++;
        -:  691:			
        -:  692:      //Each other player draws a card
      156:  693:      for (int i = 0; i < state->numPlayers; i++)
        -:  694:	{
       52:  695:	  if ( i == currentPlayer )
        -:  696:	    {
       26:  697:	      drawCard(i, state);
       26:  698:	    }
       52:  699:	}
        -:  700:			
        -:  701:      //put played card in played card pile
       26:  702:      discardCard(handPos, currentPlayer, state, 0);
       26:  703:}
        -:  704:
        -:  705:void feastEffect(struct gameState *state, int currentPlayer, int temphand[], int choice1, int x)
        -:  706:{
        -:  707:  //gain card with cost up to 5
        -:  708:      //Backup hand
    #####:  709:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  710:	      temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  711:	      state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  712:      }
        -:  713:      //Backup hand
        -:  714:
        -:  715:      //Update Coins for Buy
    #####:  716:      updateCoins(currentPlayer, state, 5);
    #####:  717:      x = 1;//Condition to loop on
    #####:  718:      while( x == 1) {//Buy one card
    #####:  719:	      if (supplyCount(choice1, state) <= 0){
        -:  720:	        if (DEBUG)
        -:  721:	          printf("None of that card left, sorry!\n");
        -:  722:
        -:  723:	        if (DEBUG){
        -:  724:	          printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  725:	        }
    #####:  726:	      }
    #####:  727:	      else if (state->coins < getCost(choice1)){
    #####:  728:	        printf("That card is too expensive!\n");
        -:  729:
        -:  730:	        if (DEBUG){
        -:  731:	          printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  732:	        }
    #####:  733:	      }
        -:  734:	      else{
        -:  735:
        -:  736:	        if (DEBUG){
        -:  737:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  738:	        }
        -:  739:
    #####:  740:	        gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  741:	        x = 0;//No more buying cards
        -:  742:
        -:  743:	        if (DEBUG){
        -:  744:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  745:	        }
        -:  746:
        -:  747:	      }
        -:  748:      }     
        -:  749:
        -:  750:      //Reset Hand
    #####:  751:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  752:	      state->hand[currentPlayer][i] = temphand[i];
    #####:  753:	      temphand[i] = -1;
    #####:  754:      }
    #####:  755:}
        -:  756:
        -:  757:int mineEffect(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int j)
        -:  758:{
       14:  759:  int result = 0;
       14:  760:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  761:
       28:  762:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  763:	    {
    #####:  764:        result = -1;
        -:  765:	      //return -1;
    #####:  766:	    }
        -:  767:		
       28:  768:      if (choice2 > treasure_map || choice2 < curse)
        -:  769:	    {
    #####:  770:        result = -1;
        -:  771:	      //return -1;
    #####:  772:	    }
        -:  773:
       14:  774:      if ( (getCost(state->hand[currentPlayer][choice1]) + 4) > getCost(choice2) )
        -:  775:	    {
       14:  776:        result = -1;
        -:  777:	      //return -1;
       14:  778:	    }
        -:  779:
       14:  780:      gainCard(choice2, state, 2, currentPlayer);
        -:  781:
        -:  782:      //discard card from hand
       14:  783:      discardCard(handPos, currentPlayer, state, 0);
        -:  784:
        -:  785:      //discard trashed card
       56:  786:      for (int i = 0; i < state->handCount[currentPlayer]; i++)
        -:  787:	    {
       28:  788:	      if (state->hand[currentPlayer][i] == j)
        -:  789:	      {
       14:  790:	        discardCard(i, currentPlayer, state, 0);			
       14:  791:	        break;
        -:  792:	      }
       14:  793:	    }
        -:  794:			
       14:  795:      return result;
        -:  796:}
        -:  797:
        -:  798:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  799:{
        -:  800:  int i;
14397326483292946558:  801:  int j = 0;
        -:  802:  int k;
14397326483292946558:  803:  int x = 0;
        -:  804:  int index;
        -:  805:  int result;
14397326483292946558:  806:  int currentPlayer = whoseTurn(state);
14397326483292946558:  807:  int nextPlayer = currentPlayer + 1;
        -:  808:
14397326483292946558:  809:  int tributeRevealedCards[2] = {-1, -1};
        -:  810:  int temphand[MAX_HAND];// moved above the if statement
14397326483292946558:  811:  int drawntreasure=0;
14397326483292946558:  812:  int cardDrawn=0;
14397326483292946558:  813:  int z = 0;// this is the counter for the temp hand
14397326483292946558:  814:  if (nextPlayer > (state->numPlayers - 1)){
  6582881:  815:    nextPlayer = 0;
  6582881:  816:  }
        -:  817:  
        -:  818:	
        -:  819:  //uses switch to select card and perform actions
3352292577943071121:  820:  switch( card ) 
        -:  821:    {
        -:  822:    case adventurer:
474366694532:  823:      adventurerEffect(drawntreasure, state, currentPlayer, cardDrawn, temphand, z);
474366694532:  824:      return 0;
        -:  825:			
        -:  826:    case council_room:
72057594037927962:  827:      councilRoomEffect(state, currentPlayer, handPos);
72057594037927962:  828:      return 0;
        -:  829:			
        -:  830:    case feast:
68719476743:  831:      feastEffect(state, currentPlayer, temphand, choice1,x);
68719476743:  832:      return 0;
        -:  833:			
        -:  834:    case gardens:
17424526879:  835:      return -1;
        -:  836:			
        -:  837:    case mine:
7738139929303872884:  838:      result = mineEffect(state, currentPlayer, choice1, choice2, handPos, j);
7738139929303872884:  839:      return result;
        -:  840:			
        -:  841:    case remodel:
72058094107324227:  842:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  843:
72058094107324227:  844:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  845:	{
73014444037:  846:	  return -1;
        -:  847:	}
        -:  848:
9172086132:  849:      gainCard(choice2, state, 0, currentPlayer);
        -:  850:
        -:  851:      //discard card from hand
9172086132:  852:      discardCard(handPos, currentPlayer, state, 0);
        -:  853:
        -:  854:      //discard trashed card
103145724687375321:  855:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  856:	{
93224767193:  857:	  if (state->hand[currentPlayer][i] == j)
        -:  858:	    {
8525144140093551465:  859:	      discardCard(i, currentPlayer, state, 0);			
8525144140093551465:  860:	      break;
        -:  861:	    }
    29285:  862:	}
        -:  863:
        -:  864:
6217793866309828627:  865:      return 0;
        -:  866:		
        -:  867:    case smithy:
8245918788311056415:  868:      smithyEffect(state, currentPlayer, handPos);
8245918788311056415:  869:      return 0;
        -:  870:		
        -:  871:    case village:
        -:  872:      //+1 Card
1919895156:  873:      drawCard(currentPlayer, state);
        -:  874:			
        -:  875:      //+2 Actions
1919895156:  876:      state->numActions = state->numActions + 2;
        -:  877:			
        -:  878:      //discard played card from hand
1919895156:  879:      discardCard(handPos, currentPlayer, state, 0);
1919895156:  880:      return 0;
        -:  881:		
        -:  882:    case baron:
72057679937273862:  883:      state->numBuys++;//Increase buys by 1!
72057679937273862:  884:      if (choice1 > 0){//Boolean true or going to discard an estate
16919086439:  885:	int p = 0;//Iterator for hand!
16919086439:  886:	int card_not_discarded = 1;//Flag for discard set!
7308900660905877056:  887:	while(card_not_discarded){
14700501649139433493:  888:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
7166187310294237187:  889:	    state->coins += 4;//Add 4 coins to the amount of coins
7166187310294237187:  890:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
7166187310294237187:  891:	    state->discardCount[currentPlayer]++;
7194460570033353316:  892:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  893:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  894:	    }
    #####:  895:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  896:	    state->handCount[currentPlayer]--;
    #####:  897:	    card_not_discarded = 0;//Exit the loop
    #####:  898:	  }
    #####:  899:	  else if (p > state->handCount[currentPlayer]){
        -:  900:	    if(DEBUG) {
        -:  901:	      printf("No estate cards in your hand, invalid choice\n");
        -:  902:	      printf("Must gain an estate if there are any\n");
        -:  903:	    }
    #####:  904:	    if (supplyCount(estate, state) > 0){
    #####:  905:	      gainCard(estate, state, 0, currentPlayer);
    #####:  906:	      state->supplyCount[estate]--;//Decrement estates
    #####:  907:	      if (supplyCount(estate, state) == 0){
    #####:  908:		isGameOver(state);
    #####:  909:	      }
    #####:  910:	    }
    #####:  911:	    card_not_discarded = 0;//Exit the loop
    #####:  912:	  }
        -:  913:			    
        -:  914:	  else{
    #####:  915:	    p++;//Next card
        -:  916:	  }
        -:  917:	}
    #####:  918:      }
        -:  919:			    
        -:  920:      else{
    #####:  921:	if (supplyCount(estate, state) > 0){
    #####:  922:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  923:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  924:	  if (supplyCount(estate, state) == 0){
    #####:  925:	    isGameOver(state);
    #####:  926:	  }
    #####:  927:	}
        -:  928:      }
        -:  929:	    
        -:  930:      
    #####:  931:      return 0;
        -:  932:		
        -:  933:    case great_hall:
        -:  934:      //+1 Card
    #####:  935:      drawCard(currentPlayer, state);
        -:  936:			
        -:  937:      //+1 Actions
    #####:  938:      state->numActions++;
        -:  939:			
        -:  940:      //discard card from hand
    #####:  941:      discardCard(handPos, currentPlayer, state, 0);
    #####:  942:      return 0;
        -:  943:		
        -:  944:    case minion:
        -:  945:      //+1 action
    #####:  946:      state->numActions++;
        -:  947:			
        -:  948:      //discard card from hand
    #####:  949:      discardCard(handPos, currentPlayer, state, 0);
        -:  950:			
    #####:  951:      if (choice1)		//+2 coins
        -:  952:	{
    #####:  953:	  state->coins = state->coins + 2;
    #####:  954:	}
        -:  955:			
    #####:  956:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  957:	{
        -:  958:	  //discard hand
    #####:  959:	  while(numHandCards(state) > 0)
        -:  960:	    {
    #####:  961:	      discardCard(handPos, currentPlayer, state, 0);
        -:  962:	    }
        -:  963:				
        -:  964:	  //draw 4
    #####:  965:	  for (i = 0; i < 4; i++)
        -:  966:	    {
    #####:  967:	      drawCard(currentPlayer, state);
    #####:  968:	    }
        -:  969:				
        -:  970:	  //other players discard hand and redraw if hand size > 4
    #####:  971:	  for (i = 0; i < state->numPlayers; i++)
        -:  972:	    {
    #####:  973:	      if (i != currentPlayer)
        -:  974:		{
    #####:  975:		  if ( state->handCount[i] > 4 )
        -:  976:		    {
        -:  977:		      //discard hand
    #####:  978:		      while( state->handCount[i] > 0 )
        -:  979:			{
    #####:  980:			  discardCard(handPos, i, state, 0);
        -:  981:			}
        -:  982:							
        -:  983:		      //draw 4
    #####:  984:		      for (j = 0; j < 4; j++)
        -:  985:			{
    #####:  986:			  drawCard(i, state);
    #####:  987:			}
    #####:  988:		    }
    #####:  989:		}
    #####:  990:	    }
        -:  991:				
    #####:  992:	}
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case steward:
    #####:  996:      if (choice1 == 1)
        -:  997:	{
        -:  998:	  //+2 cards
    #####:  999:	  drawCard(currentPlayer, state);
    #####: 1000:	  drawCard(currentPlayer, state);
    #####: 1001:	}
    #####: 1002:      else if (choice1 == 2)
        -: 1003:	{
        -: 1004:	  //+2 coins
    #####: 1005:	  state->coins = state->coins + 2;
    #####: 1006:	}
        -: 1007:      else
        -: 1008:	{
        -: 1009:	  //trash 2 cards in hand
    #####: 1010:	  discardCard(choice2, currentPlayer, state, 1);
    #####: 1011:	  discardCard(choice3, currentPlayer, state, 1);
        -: 1012:	}
        -: 1013:			
        -: 1014:      //discard card from hand
    #####: 1015:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1016:      return 0;
        -: 1017:		
        -: 1018:    case tribute:
    #####: 1019:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1020:	if (state->deckCount[nextPlayer] > 0){
    #####: 1021:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1022:	  state->deckCount[nextPlayer]--;
    #####: 1023:	}
    #####: 1024:	else if (state->discardCount[nextPlayer] > 0){
    #####: 1025:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1026:	  state->discardCount[nextPlayer]--;
    #####: 1027:	}
        -: 1028:	else{
        -: 1029:	  //No Card to Reveal
        -: 1030:	  if (DEBUG){
        -: 1031:	    printf("No cards to reveal\n");
        -: 1032:	  }
        -: 1033:	}
    #####: 1034:      }
        -: 1035:	    
        -: 1036:      else{
    #####: 1037:	if (state->deckCount[nextPlayer] == 0){
    #####: 1038:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1039:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1040:	    state->deckCount[nextPlayer]++;
    #####: 1041:	    state->discard[nextPlayer][i] = -1;
    #####: 1042:	    state->discardCount[nextPlayer]--;
    #####: 1043:	  }
        -: 1044:			    
    #####: 1045:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####: 1046:	} 
    #####: 1047:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1048:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1049:	state->deckCount[nextPlayer]--;
    #####: 1050:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
        -: 1053:      }    
        -: 1054:		       
    #####: 1055:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1056:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1057:	state->playedCardCount++;
    #####: 1058:	tributeRevealedCards[1] = -1;
    #####: 1059:      }
        -: 1060:
    #####: 1061:      for (i = 0; i <= 2; i ++){
    #####: 1062:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1063:	  state->coins += 2;
    #####: 1064:	}
        -: 1065:		    
    #####: 1066:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1067:	  drawCard(currentPlayer, state);
    #####: 1068:	  drawCard(currentPlayer, state);
    #####: 1069:	}
        -: 1070:	else{//Action Card
    #####: 1071:	  state->numActions = state->numActions + 2;
        -: 1072:	}
    #####: 1073:      }
        -: 1074:	    
    #####: 1075:      return 0;
        -: 1076:		
        -: 1077:    case ambassador:
    #####: 1078:      j = 0;		//used to check if player has enough cards to discard
        -: 1079:
    #####: 1080:      if (choice2 > 2 || choice2 < 0)
        -: 1081:	{
    #####: 1082:	  return -1;				
        -: 1083:	}
        -: 1084:
    #####: 1085:      if (choice1 == handPos)
        -: 1086:	{
    #####: 1087:	  return -1;
        -: 1088:	}
        -: 1089:
    #####: 1090:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1091:	{
    #####: 1092:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1093:	    {
    #####: 1094:	      j++;
    #####: 1095:	    }
    #####: 1096:	}
    #####: 1097:      if (j < choice2)
        -: 1098:	{
    #####: 1099:	  return -1;				
        -: 1100:	}
        -: 1101:
        -: 1102:      if (DEBUG) 
        -: 1103:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1104:
        -: 1105:      //increase supply count for choosen card by amount being discarded
    #####: 1106:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1107:			
        -: 1108:      //each other player gains a copy of revealed card
    #####: 1109:      for (i = 0; i < state->numPlayers; i++)
        -: 1110:	{
    #####: 1111:	  if (i != currentPlayer)
        -: 1112:	    {
    #####: 1113:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1114:	    }
    #####: 1115:	}
        -: 1116:
        -: 1117:      //discard played card from hand
    #####: 1118:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1119:
        -: 1120:      //trash copies of cards returned to supply
    #####: 1121:      for (j = 0; j < choice2; j++)
        -: 1122:	{
    #####: 1123:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1124:	    {
    #####: 1125:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1126:		{
    #####: 1127:		  discardCard(i, currentPlayer, state, 1);
    #####: 1128:		  break;
        -: 1129:		}
    #####: 1130:	    }
    #####: 1131:	}			
        -: 1132:
    #####: 1133:      return 0;
        -: 1134:		
        -: 1135:    case cutpurse:
        -: 1136:
    #####: 1137:      updateCoins(currentPlayer, state, 2);
    #####: 1138:      for (i = 0; i < state->numPlayers; i++)
        -: 1139:	{
    #####: 1140:	  if (i != currentPlayer)
        -: 1141:	    {
    #####: 1142:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1143:		{
    #####: 1144:		  if (state->hand[i][j] == copper)
        -: 1145:		    {
    #####: 1146:		      discardCard(j, i, state, 0);
    #####: 1147:		      break;
        -: 1148:		    }
    #####: 1149:		  if (j == state->handCount[i])
        -: 1150:		    {
    #####: 1151:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1152:			{
        -: 1153:			  if (DEBUG)
        -: 1154:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1155:			}	
    #####: 1156:		      break;
        -: 1157:		    }		
    #####: 1158:		}
        -: 1159:					
    #####: 1160:	    }
        -: 1161:				
    #####: 1162:	}				
        -: 1163:
        -: 1164:      //discard played card from hand
    #####: 1165:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1166:
    #####: 1167:      return 0;
        -: 1168:
        -: 1169:		
        -: 1170:    case embargo: 
        -: 1171:      //+2 Coins
    #####: 1172:      state->coins = state->coins + 2;
        -: 1173:			
        -: 1174:      //see if selected pile is in play
    #####: 1175:      if ( state->supplyCount[choice1] == -1 )
        -: 1176:	{
    #####: 1177:	  return -1;
        -: 1178:	}
        -: 1179:			
        -: 1180:      //add embargo token to selected supply pile
    #####: 1181:      state->embargoTokens[choice1]++;
        -: 1182:			
        -: 1183:      //trash card
    #####: 1184:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1185:      return 0;
        -: 1186:		
        -: 1187:    case outpost:
        -: 1188:      //set outpost flag
    #####: 1189:      state->outpostPlayed++;
        -: 1190:			
        -: 1191:      //discard card
    #####: 1192:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1193:      return 0;
        -: 1194:		
        -: 1195:    case salvager:
        -: 1196:      //+1 buy
    #####: 1197:      state->numBuys++;
        -: 1198:			
    #####: 1199:      if (choice1)
        -: 1200:	{
        -: 1201:	  //gain coins equal to trashed card
    #####: 1202:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1203:	  //trash card
    #####: 1204:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1205:	}
        -: 1206:			
        -: 1207:      //discard card
    #####: 1208:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1209:      return 0;
        -: 1210:		
        -: 1211:    case sea_hag:
    #####: 1212:      for (i = 0; i < state->numPlayers; i++){
    #####: 1213:	if (i != currentPlayer){
    #####: 1214:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1215:	  state->discardCount[i]++;
    #####: 1216:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1217:	}
    #####: 1218:      }
    #####: 1219:      return 0;
        -: 1220:		
        -: 1221:    case treasure_map:
        -: 1222:      //search hand for another treasure_map
    #####: 1223:      index = -1;
    #####: 1224:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1225:	{
    #####: 1226:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1227:	    {
    #####: 1228:	      index = i;
    #####: 1229:	      break;
        -: 1230:	    }
    #####: 1231:	}
    #####: 1232:      if (index > -1)
        -: 1233:	{
        -: 1234:	  //trash both treasure cards
    #####: 1235:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1236:	  discardCard(index, currentPlayer, state, 1);
        -: 1237:
        -: 1238:	  //gain 4 Gold cards
    #####: 1239:	  for (i = 0; i < 4; i++)
        -: 1240:	    {
    #####: 1241:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1242:	    }
        -: 1243:				
        -: 1244:	  //return success
    #####: 1245:	  return 1;
        -: 1246:	}
        -: 1247:			
        -: 1248:      //no second treasure_map found in hand
    #####: 1249:      return -1;
        -: 1250:    }
        -: 1251:	
    #####: 1252:  return -1;
      359: 1253:}
        -: 1254:
        -: 1255:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1256:{
        -: 1257:	
        -: 1258:  //if card is not trashed, added to Played pile 
      161: 1259:  if (trashFlag < 1)
        -: 1260:    {
        -: 1261:      //add card to played pile
      161: 1262:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      161: 1263:      state->playedCardCount++;
      161: 1264:    }
        -: 1265:	
        -: 1266:  //set played card to -1
      161: 1267:  state->hand[currentPlayer][handPos] = -1;
        -: 1268:	
        -: 1269:  //remove card from player's hand
      161: 1270:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1271:    {
        -: 1272:      //reduce number of cards in hand
    #####: 1273:      state->handCount[currentPlayer]--;
    #####: 1274:    }
      161: 1275:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1276:    {
        -: 1277:      //reduce number of cards in hand
    #####: 1278:      state->handCount[currentPlayer]--;
    #####: 1279:    }
        -: 1280:  else 	
        -: 1281:    {
        -: 1282:      //replace discarded card with last card in hand
      161: 1283:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1284:      //set last card to -1
      161: 1285:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1286:      //reduce number of cards in hand
      161: 1287:      state->handCount[currentPlayer]--;
        -: 1288:    }
        -: 1289:	
      161: 1290:  return 0;
        -: 1291:}
        -: 1292:
        -: 1293:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1294:{
        -: 1295:  //Note: supplyPos is enum of choosen card
        -: 1296:	
        -: 1297:  //check if supply pile is empty (0) or card is not used in game (-1)
     1295: 1298:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1299:    {
       38: 1300:      return -1;
        -: 1301:    }
        -: 1302:	
        -: 1303:  //added card for [whoseTurn] current player:
        -: 1304:  // toFlag = 0 : add to discard
        -: 1305:  // toFlag = 1 : add to deck
        -: 1306:  // toFlag = 2 : add to hand
        -: 1307:
     1257: 1308:  if (toFlag == 1)
        -: 1309:    {
       26: 1310:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
       26: 1311:      state->deckCount[player]++;
       26: 1312:    }
     1231: 1313:  else if (toFlag == 2)
        -: 1314:    {
       40: 1315:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
       40: 1316:      state->handCount[player]++;
       40: 1317:    }
        -: 1318:  else
        -: 1319:    {
     1191: 1320:      state->discard[player][ state->discardCount[player] ] = supplyPos;
     1191: 1321:      state->discardCount[player]++;
        -: 1322:    }
        -: 1323:	
        -: 1324:  //decrease number in supply pile
     1257: 1325:  state->supplyCount[supplyPos]--;
        -: 1326:	 
     1257: 1327:  return 0;
     1295: 1328:}
        -: 1329:
        -: 1330:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1331:{
        -: 1332:  int i;
        -: 1333:	
        -: 1334:  //reset coin count
     1858: 1335:  state->coins = 0;
        -: 1336:
        -: 1337:  //add coins for each Treasure card in player's hand
    22506: 1338:  for (i = 0; i < state->handCount[player]; i++)
        -: 1339:    {
     9395: 1340:      if (state->hand[player][i] == copper)
        -: 1341:	{
     4445: 1342:	  state->coins += 1;
     4445: 1343:	}
     4950: 1344:      else if (state->hand[player][i] == silver)
        -: 1345:	{
     1835: 1346:	  state->coins += 2;
     1835: 1347:	}
     3115: 1348:      else if (state->hand[player][i] == gold)
        -: 1349:	{
      605: 1350:	  state->coins += 3;
      605: 1351:	}	
     9395: 1352:    }	
        -: 1353:
        -: 1354:  //add bonus
     1858: 1355:  state->coins += bonus;
        -: 1356:
     1858: 1357:  return 0;
        -: 1358:}
        -: 1359:
        -: 1360:
        -: 1361://end of dominion.c
        -: 1362:
unittest4.c:
Starting test for gainCard()...

TEST: Gold supply pile is empty
Actual: -1
Expected: -1
PASSED

TEST: Add card to deck
Actual: 6
Expected: 6
PASSED

TEST: Add card to hand
Actual: 6
Expected: 6
PASSED

TEST: Add card to discard pile
Actual: 1
Expected: 1
PASSED

TEST: Decrease gold supply
Actual: 26
Expected: 26
PASSED

TESTS SUCCESSFULLY COMPLETED

File 'unittest4.c'
Lines executed:87.76% of 49
unittest4.c:creating 'unittest4.c.gcov'

File 'dominion.c'
Lines executed:52.59% of 656
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:257
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    23879:    9:  if (*(int*)a > *(int*)b)
     4441:   10:    return 1;
    19438:   11:  if (*(int*)a < *(int*)b)
     8174:   12:    return -1;
    11264:   13:  return 0;
    23879:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      286:   44:  SelectStream(1);
      286:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
      572:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      286:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     6292:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    62920:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    54340:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    28600:   65:        }
     2860:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      286:   73:  if (numPlayers == 2)
        -:   74:    {
      286:   75:      state->supplyCount[curse] = 10;
      286:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      286:   87:  if (numPlayers == 2)
        -:   88:    {
      286:   89:      state->supplyCount[estate] = 8;
      286:   90:      state->supplyCount[duchy] = 8;
      286:   91:      state->supplyCount[province] = 8;
      286:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      286:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      286:  102:  state->supplyCount[silver] = 40;
      286:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    12012:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    94380:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    44330:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     5467:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
      539:  115:		  if (numPlayers == 2){ 
      539:  116:		    state->supplyCount[i] = 8; 
      539:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
      539:  119:		}
        -:  120:	      else
        -:  121:		{
     2321:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     2860:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    41470:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    41470:  130:	}
        -:  131:
     5720:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     1716:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
      572:  140:      state->deckCount[i] = 0;
     4576:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
     1716:  143:	  state->deck[i][j] = estate;
     1716:  144:	  state->deckCount[i]++;
     1716:  145:	}
     9152:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
     4004:  148:	  state->deck[i][j] = copper;
     4004:  149:	  state->deckCount[i]++;		
     4004:  150:	}
      572:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     1716:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
      572:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
      572:  160:    }
        -:  161:
        -:  162:  //draw player hands
     1716:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      572:  166:      state->handCount[i] = 0;
      572:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
      572:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    16016:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
     7722:  178:      state->embargoTokens[i] = 0;
     7722:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      286:  182:  state->outpostPlayed = 0;
      286:  183:  state->phase = 0;
      286:  184:  state->numActions = 1;
      286:  185:  state->numBuys = 1;
      286:  186:  state->playedCardCount = 0;
      286:  187:  state->whoseTurn = 0;
      286:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     3432:  192:  for (it = 0; it < 5; it++){
     1430:  193:    drawCard(state->whoseTurn, state);
     1430:  194:  }
        -:  195:
      286:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
      286:  198:  return 0;
      286:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     1147:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     1147:  209:  if (state->deckCount[player] < 1)
       72:  210:    return -1;
     1075:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    28602:  214:  while (state->deckCount[player] > 0) {
    13226:  215:    card = floor(Random() * state->deckCount[player]);
    13226:  216:    newDeck[newDeckPos] = state->deck[player][card];
    13226:  217:    newDeckPos++;
   117442:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    45495:  219:      state->deck[player][i] = state->deck[player][i+1];
    45495:  220:    }
    13226:  221:    state->deckCount[player]--;
        -:  222:  }
    28602:  223:  for (i = 0; i < newDeckPos; i++) {
    13226:  224:    state->deck[player][i] = newDeck[i];
    13226:  225:    state->deckCount[player]++;
    13226:  226:  }
        -:  227:
     1075:  228:  return 0;
     1147:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
     1466:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
     1466:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
     1466:  243:  if ( state->numActions < 1 )
        -:  244:    {
     1217:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
      249:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
      494:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
        4:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
      245:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
      245:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
      245:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
      245:  269:  return 0;
     1466:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
     1139:  280:  who = state->whoseTurn;
        -:  281:
     1139:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
     1139:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
     1139:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
     1139:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
     1139:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  298:  
     1139:  299:    state->coins = (state->coins) - (getCost(supplyPos));
     1139:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
     1139:  308:  return 0;
     1139:  309:}
        -:  310:
        -:  311:int numHandCards(struct gameState *state) {
     8955:  312:  return state->handCount[ whoseTurn(state) ];
        -:  313:}
        -:  314:
        -:  315:int handCard(int handPos, struct gameState *state) {
    18023:  316:  int currentPlayer = whoseTurn(state);
    18023:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
        -:  320:int supplyCount(int card, struct gameState *state) {
     2440:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
        -:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
    #####:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
    #####:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
    #####:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
        -:  346:int whoseTurn(struct gameState *state) {
    29649:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
        -:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
     1160:  353:  int currentPlayer = whoseTurn(state);
        -:  354:  
        -:  355:  //Discard hand
    14970:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
     6325:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     6325:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
     6325:  359:  }
     1160:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
     1160:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
      588:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
      588:  365:  }
        -:  366:  else{
      572:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
     1160:  370:  state->outpostPlayed = 0;
     1160:  371:  state->phase = 0;
     1160:  372:  state->numActions = 1;
     1160:  373:  state->coins = 0;
     1160:  374:  state->numBuys = 1;
     1160:  375:  state->playedCardCount = 0;
     1160:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    13920:  380:  for (k = 0; k < 5; k++){
     5800:  381:    drawCard(state->whoseTurn, state);//Draw a card
     5800:  382:  }
        -:  383:
        -:  384:  //Update money
     1160:  385:  updateCoins(state->whoseTurn, state , 0);
        -:  386:
     1160:  387:  return 0;
        -:  388:}
        -:  389:
        -:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
     1318:  395:  if (state->supplyCount[province] == 0)
        -:  396:    {
       74:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
     1244:  401:  j = 0;
    64688:  402:  for (i = 0; i < 25; i++)
        -:  403:    {
    31100:  404:      if (state->supplyCount[i] == 0)
        -:  405:	{
      126:  406:	  j++;
      126:  407:	}
    31100:  408:    }
     1244:  409:  if ( j >= 3)
        -:  410:    {
       42:  411:      return 1;
        -:  412:    }
        -:  413:
     1202:  414:  return 0;
     1318:  415:}
        -:  416:
        -:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
       64:  420:  int score = 0;
        -:  421:  //score from hand
      448:  422:  for (i = 0; i < state->handCount[player]; i++)
        -:  423:    {
      160:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
      180:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
      160:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
      177:  427:      if (state->hand[player][i] == province) { score = score + 6; };
      160:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
      160:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      160:  430:    }
        -:  431:
        -:  432:  //score from discard
     1398:  433:  for (i = 0; i < state->discardCount[player]; i++)
        -:  434:    {
      635:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
      702:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
      635:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
      752:  438:      if (state->discard[player][i] == province) { score = score + 6; };
      635:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
      635:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  441:    }
        -:  442:
        -:  443:  //score from deck
     1398:  444:  for (i = 0; i < state->discardCount[player]; i++)
        -:  445:    {
      670:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
      691:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
      635:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
      719:  449:      if (state->deck[player][i] == province) { score = score + 6; };
      635:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
      635:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  452:    }
        -:  453:
       64:  454:  return score;
        -:  455:}
        -:  456:
        -:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
        -:  468:	{
    #####:  469:	  players[i] = -9999;
    #####:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
        -:  474:	}
    #####:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
        -:  482:	{
    #####:  483:	  j = i;
    #####:  484:	}
    #####:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
        -:  493:	{
    #####:  494:	  players[i]++;
    #####:  495:	}
    #####:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
        -:  503:	{
    #####:  504:	  j = i;
    #####:  505:	}
    #####:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
        -:  513:	{
    #####:  514:	  players[i] = 1;
    #####:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
    #####:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
        -:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     8230:  528:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    14786:  533:    for (i = 0; i < state->discardCount[player];i++){
     6946:  534:      state->deck[player][i] = state->discard[player][i];
     6946:  535:      state->discard[player][i] = -1;
     6946:  536:    }
        -:  537:
      447:  538:    state->deckCount[player] = state->discardCount[player];
      447:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
      447:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
      447:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
      447:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
      447:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
      447:  559:    if (deckCounter == 0)
    #####:  560:      return -1;
        -:  561:
      447:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      447:  563:    state->deckCount[player]--;
      447:  564:    state->handCount[player]++;//Increment hand count
      447:  565:  }
        -:  566:
        -:  567:  else{
     7783:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     7783:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     7783:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     7783:  576:    state->deckCount[player]--;
     7783:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     8230:  580:  return 0;
     8230:  581:}
        -:  582:
        -:  583:int getCost(int cardNumber)
        -:  584:{
     2306:  585:  switch( cardNumber ) 
        -:  586:    {
        -:  587:    case curse:
       10:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
      512:  594:      return 8;
        -:  595:    case copper:
       14:  596:      return 0;
        -:  597:    case silver:
      888:  598:      return 3;
        -:  599:    case gold:
      626:  600:      return 6;
        -:  601:    case adventurer:
      128:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
      128:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
     2306:  644:}
        -:  645:
        -:  646:
        -:  647:void adventurerEffect(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand[], int z)
        -:  648:{
     1646:  649:  while(drawntreasure<=2){
      611:  650:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
       30:  651:	  shuffle(currentPlayer, state);
       30:  652:	}
      611:  653:	drawCard(currentPlayer, state);
      611:  654:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     1074:  655:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
      494:  656:	  drawntreasure++;
        -:  657:	else{
      117:  658:	  temphand[z]=cardDrawn;
      117:  659:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
      117:  660:	  z++;
        -:  661:	}
        -:  662:      }
      658:  663:      while(z-1>=0){
      117:  664:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
      117:  665:	z=z-1;
        -:  666:      }
      212:  667:}
        -:  668:
        -:  669:void smithyEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  670:{
        -:  671:  //+3 Cards
      672:  672:      for (int i = 1; i < 3; i++)
        -:  673:	{
      244:  674:	  drawCard(currentPlayer, state);
      244:  675:	}
        -:  676:			
        -:  677:      //discard card from hand
       92:  678:      discardCard(handPos, currentPlayer, state, 0);
       92:  679:}
        -:  680:
        -:  681:void councilRoomEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  682:{
        -:  683:  //+4 Cards
      260:  684:      for (int i = 0; i < 4; i++)
        -:  685:	{
      104:  686:	  drawCard(currentPlayer, state);
      104:  687:	}
        -:  688:			
        -:  689:      //+1 Buy
       26:  690:      state->numBuys++;
        -:  691:			
        -:  692:      //Each other player draws a card
      156:  693:      for (int i = 0; i < state->numPlayers; i++)
        -:  694:	{
       52:  695:	  if ( i == currentPlayer )
        -:  696:	    {
       26:  697:	      drawCard(i, state);
       26:  698:	    }
       52:  699:	}
        -:  700:			
        -:  701:      //put played card in played card pile
       26:  702:      discardCard(handPos, currentPlayer, state, 0);
       26:  703:}
        -:  704:
        -:  705:void feastEffect(struct gameState *state, int currentPlayer, int temphand[], int choice1, int x)
        -:  706:{
        -:  707:  //gain card with cost up to 5
        -:  708:      //Backup hand
    #####:  709:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  710:	      temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  711:	      state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  712:      }
        -:  713:      //Backup hand
        -:  714:
        -:  715:      //Update Coins for Buy
    #####:  716:      updateCoins(currentPlayer, state, 5);
    #####:  717:      x = 1;//Condition to loop on
    #####:  718:      while( x == 1) {//Buy one card
    #####:  719:	      if (supplyCount(choice1, state) <= 0){
        -:  720:	        if (DEBUG)
        -:  721:	          printf("None of that card left, sorry!\n");
        -:  722:
        -:  723:	        if (DEBUG){
        -:  724:	          printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  725:	        }
    #####:  726:	      }
    #####:  727:	      else if (state->coins < getCost(choice1)){
    #####:  728:	        printf("That card is too expensive!\n");
        -:  729:
        -:  730:	        if (DEBUG){
        -:  731:	          printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  732:	        }
    #####:  733:	      }
        -:  734:	      else{
        -:  735:
        -:  736:	        if (DEBUG){
        -:  737:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  738:	        }
        -:  739:
    #####:  740:	        gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  741:	        x = 0;//No more buying cards
        -:  742:
        -:  743:	        if (DEBUG){
        -:  744:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  745:	        }
        -:  746:
        -:  747:	      }
        -:  748:      }     
        -:  749:
        -:  750:      //Reset Hand
    #####:  751:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  752:	      state->hand[currentPlayer][i] = temphand[i];
    #####:  753:	      temphand[i] = -1;
    #####:  754:      }
    #####:  755:}
        -:  756:
        -:  757:int mineEffect(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int j)
        -:  758:{
       14:  759:  int result = 0;
       14:  760:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  761:
       28:  762:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  763:	    {
    #####:  764:        result = -1;
        -:  765:	      //return -1;
    #####:  766:	    }
        -:  767:		
       28:  768:      if (choice2 > treasure_map || choice2 < curse)
        -:  769:	    {
    #####:  770:        result = -1;
        -:  771:	      //return -1;
    #####:  772:	    }
        -:  773:
       14:  774:      if ( (getCost(state->hand[currentPlayer][choice1]) + 4) > getCost(choice2) )
        -:  775:	    {
       14:  776:        result = -1;
        -:  777:	      //return -1;
       14:  778:	    }
        -:  779:
       14:  780:      gainCard(choice2, state, 2, currentPlayer);
        -:  781:
        -:  782:      //discard card from hand
       14:  783:      discardCard(handPos, currentPlayer, state, 0);
        -:  784:
        -:  785:      //discard trashed card
       56:  786:      for (int i = 0; i < state->handCount[currentPlayer]; i++)
        -:  787:	    {
       28:  788:	      if (state->hand[currentPlayer][i] == j)
        -:  789:	      {
       14:  790:	        discardCard(i, currentPlayer, state, 0);			
       14:  791:	        break;
        -:  792:	      }
       14:  793:	    }
        -:  794:			
       14:  795:      return result;
        -:  796:}
        -:  797:
        -:  798:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  799:{
        -:  800:  int i;
14397326483292946558:  801:  int j = 0;
        -:  802:  int k;
14397326483292946558:  803:  int x = 0;
        -:  804:  int index;
        -:  805:  int result;
14397326483292946558:  806:  int currentPlayer = whoseTurn(state);
14397326483292946558:  807:  int nextPlayer = currentPlayer + 1;
        -:  808:
14397326483292946558:  809:  int tributeRevealedCards[2] = {-1, -1};
        -:  810:  int temphand[MAX_HAND];// moved above the if statement
14397326483292946558:  811:  int drawntreasure=0;
14397326483292946558:  812:  int cardDrawn=0;
14397326483292946558:  813:  int z = 0;// this is the counter for the temp hand
14397326483292946558:  814:  if (nextPlayer > (state->numPlayers - 1)){
  6582881:  815:    nextPlayer = 0;
  6582881:  816:  }
        -:  817:  
        -:  818:	
        -:  819:  //uses switch to select card and perform actions
3352292577943071121:  820:  switch( card ) 
        -:  821:    {
        -:  822:    case adventurer:
474366694532:  823:      adventurerEffect(drawntreasure, state, currentPlayer, cardDrawn, temphand, z);
474366694532:  824:      return 0;
        -:  825:			
        -:  826:    case council_room:
72057594037927962:  827:      councilRoomEffect(state, currentPlayer, handPos);
72057594037927962:  828:      return 0;
        -:  829:			
        -:  830:    case feast:
68719476743:  831:      feastEffect(state, currentPlayer, temphand, choice1,x);
68719476743:  832:      return 0;
        -:  833:			
        -:  834:    case gardens:
17424526879:  835:      return -1;
        -:  836:			
        -:  837:    case mine:
7738139929303872884:  838:      result = mineEffect(state, currentPlayer, choice1, choice2, handPos, j);
7738139929303872884:  839:      return result;
        -:  840:			
        -:  841:    case remodel:
72058094107324227:  842:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  843:
72058094107324227:  844:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  845:	{
73014444037:  846:	  return -1;
        -:  847:	}
        -:  848:
9172086132:  849:      gainCard(choice2, state, 0, currentPlayer);
        -:  850:
        -:  851:      //discard card from hand
9172086132:  852:      discardCard(handPos, currentPlayer, state, 0);
        -:  853:
        -:  854:      //discard trashed card
103145724687375321:  855:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  856:	{
93224767193:  857:	  if (state->hand[currentPlayer][i] == j)
        -:  858:	    {
8525144140093551465:  859:	      discardCard(i, currentPlayer, state, 0);			
8525144140093551465:  860:	      break;
        -:  861:	    }
    29285:  862:	}
        -:  863:
        -:  864:
6217793866309828627:  865:      return 0;
        -:  866:		
        -:  867:    case smithy:
8245918788311056415:  868:      smithyEffect(state, currentPlayer, handPos);
8245918788311056415:  869:      return 0;
        -:  870:		
        -:  871:    case village:
        -:  872:      //+1 Card
1919895156:  873:      drawCard(currentPlayer, state);
        -:  874:			
        -:  875:      //+2 Actions
1919895156:  876:      state->numActions = state->numActions + 2;
        -:  877:			
        -:  878:      //discard played card from hand
1919895156:  879:      discardCard(handPos, currentPlayer, state, 0);
1919895156:  880:      return 0;
        -:  881:		
        -:  882:    case baron:
72057679937273862:  883:      state->numBuys++;//Increase buys by 1!
72057679937273862:  884:      if (choice1 > 0){//Boolean true or going to discard an estate
16919086439:  885:	int p = 0;//Iterator for hand!
16919086439:  886:	int card_not_discarded = 1;//Flag for discard set!
7308900660905877056:  887:	while(card_not_discarded){
14700501649139433493:  888:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
7166187310294237187:  889:	    state->coins += 4;//Add 4 coins to the amount of coins
7166187310294237187:  890:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
7166187310294237187:  891:	    state->discardCount[currentPlayer]++;
7194460570033353316:  892:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  893:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  894:	    }
    #####:  895:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  896:	    state->handCount[currentPlayer]--;
    #####:  897:	    card_not_discarded = 0;//Exit the loop
    #####:  898:	  }
    #####:  899:	  else if (p > state->handCount[currentPlayer]){
        -:  900:	    if(DEBUG) {
        -:  901:	      printf("No estate cards in your hand, invalid choice\n");
        -:  902:	      printf("Must gain an estate if there are any\n");
        -:  903:	    }
    #####:  904:	    if (supplyCount(estate, state) > 0){
    #####:  905:	      gainCard(estate, state, 0, currentPlayer);
    #####:  906:	      state->supplyCount[estate]--;//Decrement estates
    #####:  907:	      if (supplyCount(estate, state) == 0){
    #####:  908:		isGameOver(state);
    #####:  909:	      }
    #####:  910:	    }
    #####:  911:	    card_not_discarded = 0;//Exit the loop
    #####:  912:	  }
        -:  913:			    
        -:  914:	  else{
    #####:  915:	    p++;//Next card
        -:  916:	  }
        -:  917:	}
    #####:  918:      }
        -:  919:			    
        -:  920:      else{
    #####:  921:	if (supplyCount(estate, state) > 0){
    #####:  922:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  923:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  924:	  if (supplyCount(estate, state) == 0){
    #####:  925:	    isGameOver(state);
    #####:  926:	  }
    #####:  927:	}
        -:  928:      }
        -:  929:	    
        -:  930:      
    #####:  931:      return 0;
        -:  932:		
        -:  933:    case great_hall:
        -:  934:      //+1 Card
    #####:  935:      drawCard(currentPlayer, state);
        -:  936:			
        -:  937:      //+1 Actions
    #####:  938:      state->numActions++;
        -:  939:			
        -:  940:      //discard card from hand
    #####:  941:      discardCard(handPos, currentPlayer, state, 0);
    #####:  942:      return 0;
        -:  943:		
        -:  944:    case minion:
        -:  945:      //+1 action
    #####:  946:      state->numActions++;
        -:  947:			
        -:  948:      //discard card from hand
    #####:  949:      discardCard(handPos, currentPlayer, state, 0);
        -:  950:			
    #####:  951:      if (choice1)		//+2 coins
        -:  952:	{
    #####:  953:	  state->coins = state->coins + 2;
    #####:  954:	}
        -:  955:			
    #####:  956:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  957:	{
        -:  958:	  //discard hand
    #####:  959:	  while(numHandCards(state) > 0)
        -:  960:	    {
    #####:  961:	      discardCard(handPos, currentPlayer, state, 0);
        -:  962:	    }
        -:  963:				
        -:  964:	  //draw 4
    #####:  965:	  for (i = 0; i < 4; i++)
        -:  966:	    {
    #####:  967:	      drawCard(currentPlayer, state);
    #####:  968:	    }
        -:  969:				
        -:  970:	  //other players discard hand and redraw if hand size > 4
    #####:  971:	  for (i = 0; i < state->numPlayers; i++)
        -:  972:	    {
    #####:  973:	      if (i != currentPlayer)
        -:  974:		{
    #####:  975:		  if ( state->handCount[i] > 4 )
        -:  976:		    {
        -:  977:		      //discard hand
    #####:  978:		      while( state->handCount[i] > 0 )
        -:  979:			{
    #####:  980:			  discardCard(handPos, i, state, 0);
        -:  981:			}
        -:  982:							
        -:  983:		      //draw 4
    #####:  984:		      for (j = 0; j < 4; j++)
        -:  985:			{
    #####:  986:			  drawCard(i, state);
    #####:  987:			}
    #####:  988:		    }
    #####:  989:		}
    #####:  990:	    }
        -:  991:				
    #####:  992:	}
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case steward:
    #####:  996:      if (choice1 == 1)
        -:  997:	{
        -:  998:	  //+2 cards
    #####:  999:	  drawCard(currentPlayer, state);
    #####: 1000:	  drawCard(currentPlayer, state);
    #####: 1001:	}
    #####: 1002:      else if (choice1 == 2)
        -: 1003:	{
        -: 1004:	  //+2 coins
    #####: 1005:	  state->coins = state->coins + 2;
    #####: 1006:	}
        -: 1007:      else
        -: 1008:	{
        -: 1009:	  //trash 2 cards in hand
    #####: 1010:	  discardCard(choice2, currentPlayer, state, 1);
    #####: 1011:	  discardCard(choice3, currentPlayer, state, 1);
        -: 1012:	}
        -: 1013:			
        -: 1014:      //discard card from hand
    #####: 1015:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1016:      return 0;
        -: 1017:		
        -: 1018:    case tribute:
    #####: 1019:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1020:	if (state->deckCount[nextPlayer] > 0){
    #####: 1021:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1022:	  state->deckCount[nextPlayer]--;
    #####: 1023:	}
    #####: 1024:	else if (state->discardCount[nextPlayer] > 0){
    #####: 1025:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1026:	  state->discardCount[nextPlayer]--;
    #####: 1027:	}
        -: 1028:	else{
        -: 1029:	  //No Card to Reveal
        -: 1030:	  if (DEBUG){
        -: 1031:	    printf("No cards to reveal\n");
        -: 1032:	  }
        -: 1033:	}
    #####: 1034:      }
        -: 1035:	    
        -: 1036:      else{
    #####: 1037:	if (state->deckCount[nextPlayer] == 0){
    #####: 1038:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1039:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1040:	    state->deckCount[nextPlayer]++;
    #####: 1041:	    state->discard[nextPlayer][i] = -1;
    #####: 1042:	    state->discardCount[nextPlayer]--;
    #####: 1043:	  }
        -: 1044:			    
    #####: 1045:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####: 1046:	} 
    #####: 1047:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1048:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1049:	state->deckCount[nextPlayer]--;
    #####: 1050:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
        -: 1053:      }    
        -: 1054:		       
    #####: 1055:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1056:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1057:	state->playedCardCount++;
    #####: 1058:	tributeRevealedCards[1] = -1;
    #####: 1059:      }
        -: 1060:
    #####: 1061:      for (i = 0; i <= 2; i ++){
    #####: 1062:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1063:	  state->coins += 2;
    #####: 1064:	}
        -: 1065:		    
    #####: 1066:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1067:	  drawCard(currentPlayer, state);
    #####: 1068:	  drawCard(currentPlayer, state);
    #####: 1069:	}
        -: 1070:	else{//Action Card
    #####: 1071:	  state->numActions = state->numActions + 2;
        -: 1072:	}
    #####: 1073:      }
        -: 1074:	    
    #####: 1075:      return 0;
        -: 1076:		
        -: 1077:    case ambassador:
    #####: 1078:      j = 0;		//used to check if player has enough cards to discard
        -: 1079:
    #####: 1080:      if (choice2 > 2 || choice2 < 0)
        -: 1081:	{
    #####: 1082:	  return -1;				
        -: 1083:	}
        -: 1084:
    #####: 1085:      if (choice1 == handPos)
        -: 1086:	{
    #####: 1087:	  return -1;
        -: 1088:	}
        -: 1089:
    #####: 1090:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1091:	{
    #####: 1092:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1093:	    {
    #####: 1094:	      j++;
    #####: 1095:	    }
    #####: 1096:	}
    #####: 1097:      if (j < choice2)
        -: 1098:	{
    #####: 1099:	  return -1;				
        -: 1100:	}
        -: 1101:
        -: 1102:      if (DEBUG) 
        -: 1103:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1104:
        -: 1105:      //increase supply count for choosen card by amount being discarded
    #####: 1106:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1107:			
        -: 1108:      //each other player gains a copy of revealed card
    #####: 1109:      for (i = 0; i < state->numPlayers; i++)
        -: 1110:	{
    #####: 1111:	  if (i != currentPlayer)
        -: 1112:	    {
    #####: 1113:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1114:	    }
    #####: 1115:	}
        -: 1116:
        -: 1117:      //discard played card from hand
    #####: 1118:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1119:
        -: 1120:      //trash copies of cards returned to supply
    #####: 1121:      for (j = 0; j < choice2; j++)
        -: 1122:	{
    #####: 1123:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1124:	    {
    #####: 1125:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1126:		{
    #####: 1127:		  discardCard(i, currentPlayer, state, 1);
    #####: 1128:		  break;
        -: 1129:		}
    #####: 1130:	    }
    #####: 1131:	}			
        -: 1132:
    #####: 1133:      return 0;
        -: 1134:		
        -: 1135:    case cutpurse:
        -: 1136:
    #####: 1137:      updateCoins(currentPlayer, state, 2);
    #####: 1138:      for (i = 0; i < state->numPlayers; i++)
        -: 1139:	{
    #####: 1140:	  if (i != currentPlayer)
        -: 1141:	    {
    #####: 1142:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1143:		{
    #####: 1144:		  if (state->hand[i][j] == copper)
        -: 1145:		    {
    #####: 1146:		      discardCard(j, i, state, 0);
    #####: 1147:		      break;
        -: 1148:		    }
    #####: 1149:		  if (j == state->handCount[i])
        -: 1150:		    {
    #####: 1151:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1152:			{
        -: 1153:			  if (DEBUG)
        -: 1154:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1155:			}	
    #####: 1156:		      break;
        -: 1157:		    }		
    #####: 1158:		}
        -: 1159:					
    #####: 1160:	    }
        -: 1161:				
    #####: 1162:	}				
        -: 1163:
        -: 1164:      //discard played card from hand
    #####: 1165:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1166:
    #####: 1167:      return 0;
        -: 1168:
        -: 1169:		
        -: 1170:    case embargo: 
        -: 1171:      //+2 Coins
    #####: 1172:      state->coins = state->coins + 2;
        -: 1173:			
        -: 1174:      //see if selected pile is in play
    #####: 1175:      if ( state->supplyCount[choice1] == -1 )
        -: 1176:	{
    #####: 1177:	  return -1;
        -: 1178:	}
        -: 1179:			
        -: 1180:      //add embargo token to selected supply pile
    #####: 1181:      state->embargoTokens[choice1]++;
        -: 1182:			
        -: 1183:      //trash card
    #####: 1184:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1185:      return 0;
        -: 1186:		
        -: 1187:    case outpost:
        -: 1188:      //set outpost flag
    #####: 1189:      state->outpostPlayed++;
        -: 1190:			
        -: 1191:      //discard card
    #####: 1192:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1193:      return 0;
        -: 1194:		
        -: 1195:    case salvager:
        -: 1196:      //+1 buy
    #####: 1197:      state->numBuys++;
        -: 1198:			
    #####: 1199:      if (choice1)
        -: 1200:	{
        -: 1201:	  //gain coins equal to trashed card
    #####: 1202:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1203:	  //trash card
    #####: 1204:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1205:	}
        -: 1206:			
        -: 1207:      //discard card
    #####: 1208:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1209:      return 0;
        -: 1210:		
        -: 1211:    case sea_hag:
    #####: 1212:      for (i = 0; i < state->numPlayers; i++){
    #####: 1213:	if (i != currentPlayer){
    #####: 1214:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1215:	  state->discardCount[i]++;
    #####: 1216:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1217:	}
    #####: 1218:      }
    #####: 1219:      return 0;
        -: 1220:		
        -: 1221:    case treasure_map:
        -: 1222:      //search hand for another treasure_map
    #####: 1223:      index = -1;
    #####: 1224:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1225:	{
    #####: 1226:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1227:	    {
    #####: 1228:	      index = i;
    #####: 1229:	      break;
        -: 1230:	    }
    #####: 1231:	}
    #####: 1232:      if (index > -1)
        -: 1233:	{
        -: 1234:	  //trash both treasure cards
    #####: 1235:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1236:	  discardCard(index, currentPlayer, state, 1);
        -: 1237:
        -: 1238:	  //gain 4 Gold cards
    #####: 1239:	  for (i = 0; i < 4; i++)
        -: 1240:	    {
    #####: 1241:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1242:	    }
        -: 1243:				
        -: 1244:	  //return success
    #####: 1245:	  return 1;
        -: 1246:	}
        -: 1247:			
        -: 1248:      //no second treasure_map found in hand
    #####: 1249:      return -1;
        -: 1250:    }
        -: 1251:	
    #####: 1252:  return -1;
      359: 1253:}
        -: 1254:
        -: 1255:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1256:{
        -: 1257:	
        -: 1258:  //if card is not trashed, added to Played pile 
      161: 1259:  if (trashFlag < 1)
        -: 1260:    {
        -: 1261:      //add card to played pile
      161: 1262:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      161: 1263:      state->playedCardCount++;
      161: 1264:    }
        -: 1265:	
        -: 1266:  //set played card to -1
      161: 1267:  state->hand[currentPlayer][handPos] = -1;
        -: 1268:	
        -: 1269:  //remove card from player's hand
      161: 1270:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1271:    {
        -: 1272:      //reduce number of cards in hand
    #####: 1273:      state->handCount[currentPlayer]--;
    #####: 1274:    }
      161: 1275:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1276:    {
        -: 1277:      //reduce number of cards in hand
    #####: 1278:      state->handCount[currentPlayer]--;
    #####: 1279:    }
        -: 1280:  else 	
        -: 1281:    {
        -: 1282:      //replace discarded card with last card in hand
      161: 1283:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1284:      //set last card to -1
      161: 1285:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1286:      //reduce number of cards in hand
      161: 1287:      state->handCount[currentPlayer]--;
        -: 1288:    }
        -: 1289:	
      161: 1290:  return 0;
        -: 1291:}
        -: 1292:
        -: 1293:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1294:{
        -: 1295:  //Note: supplyPos is enum of choosen card
        -: 1296:	
        -: 1297:  //check if supply pile is empty (0) or card is not used in game (-1)
     1301: 1298:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1299:    {
       40: 1300:      return -1;
        -: 1301:    }
        -: 1302:	
        -: 1303:  //added card for [whoseTurn] current player:
        -: 1304:  // toFlag = 0 : add to discard
        -: 1305:  // toFlag = 1 : add to deck
        -: 1306:  // toFlag = 2 : add to hand
        -: 1307:
     1261: 1308:  if (toFlag == 1)
        -: 1309:    {
       27: 1310:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
       27: 1311:      state->deckCount[player]++;
       27: 1312:    }
     1234: 1313:  else if (toFlag == 2)
        -: 1314:    {
       41: 1315:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
       41: 1316:      state->handCount[player]++;
       41: 1317:    }
        -: 1318:  else
        -: 1319:    {
     1193: 1320:      state->discard[player][ state->discardCount[player] ] = supplyPos;
     1193: 1321:      state->discardCount[player]++;
        -: 1322:    }
        -: 1323:	
        -: 1324:  //decrease number in supply pile
     1261: 1325:  state->supplyCount[supplyPos]--;
        -: 1326:	 
     1261: 1327:  return 0;
     1301: 1328:}
        -: 1329:
        -: 1330:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1331:{
        -: 1332:  int i;
        -: 1333:	
        -: 1334:  //reset coin count
     1859: 1335:  state->coins = 0;
        -: 1336:
        -: 1337:  //add coins for each Treasure card in player's hand
    22518: 1338:  for (i = 0; i < state->handCount[player]; i++)
        -: 1339:    {
     9400: 1340:      if (state->hand[player][i] == copper)
        -: 1341:	{
     4449: 1342:	  state->coins += 1;
     4449: 1343:	}
     4951: 1344:      else if (state->hand[player][i] == silver)
        -: 1345:	{
     1835: 1346:	  state->coins += 2;
     1835: 1347:	}
     3116: 1348:      else if (state->hand[player][i] == gold)
        -: 1349:	{
      605: 1350:	  state->coins += 3;
      605: 1351:	}	
     9400: 1352:    }	
        -: 1353:
        -: 1354:  //add bonus
     1859: 1355:  state->coins += bonus;
        -: 1356:
     1859: 1357:  return 0;
        -: 1358:}
        -: 1359:
        -: 1360:
        -: 1361://end of dominion.c
        -: 1362:
cardtest1.c:
Starting tests for adventurerEffect()...

TEST: Player 0 gains 2 cards
Actual: 8
Expected: 7
FAILED

TEST: Player 0 gains 2 treasure cards
Actual: 7
Expected: 6
FAILED

TEST: No changes to victory card piles
Province Pile
Actual: 8
Expected: 8
PASSED

Duchy Pile
Actual: 8
Expected: 8
PASSED

Estate Pile
Actual: 8
Expected: 8
PASSED

TEST: No changes to kingdom card piles
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED

TEST: Player 1 was not affected
Hand Count
Actual: 0
Expected: 0
PASSED

Deck Count
Actual: 10
Expected: 10
PASSED

TEST(S) FAILED
2 of 17 tests failed!
File 'cardtest1.c'
Lines executed:98.70% of 77
cardtest1.c:creating 'cardtest1.c.gcov'

File 'dominion.c'
Lines executed:52.59% of 656
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:258
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    23907:    9:  if (*(int*)a > *(int*)b)
     4441:   10:    return 1;
    19466:   11:  if (*(int*)a < *(int*)b)
     8184:   12:    return -1;
    11282:   13:  return 0;
    23907:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      287:   44:  SelectStream(1);
      287:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
      574:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      287:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     6314:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    63140:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    54530:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    28700:   65:        }
     2870:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      287:   73:  if (numPlayers == 2)
        -:   74:    {
      287:   75:      state->supplyCount[curse] = 10;
      287:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      287:   87:  if (numPlayers == 2)
        -:   88:    {
      287:   89:      state->supplyCount[estate] = 8;
      287:   90:      state->supplyCount[duchy] = 8;
      287:   91:      state->supplyCount[province] = 8;
      287:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      287:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      287:  102:  state->supplyCount[silver] = 40;
      287:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    12054:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    94710:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    44485:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     5486:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
      541:  115:		  if (numPlayers == 2){ 
      541:  116:		    state->supplyCount[i] = 8; 
      541:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
      541:  119:		}
        -:  120:	      else
        -:  121:		{
     2329:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     2870:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    41615:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    41615:  130:	}
        -:  131:
     5740:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     1722:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
      574:  140:      state->deckCount[i] = 0;
     4592:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
     1722:  143:	  state->deck[i][j] = estate;
     1722:  144:	  state->deckCount[i]++;
     1722:  145:	}
     9184:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
     4018:  148:	  state->deck[i][j] = copper;
     4018:  149:	  state->deckCount[i]++;		
     4018:  150:	}
      574:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     1722:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
      574:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
      574:  160:    }
        -:  161:
        -:  162:  //draw player hands
     1722:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      574:  166:      state->handCount[i] = 0;
      574:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
      574:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    16072:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
     7749:  178:      state->embargoTokens[i] = 0;
     7749:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      287:  182:  state->outpostPlayed = 0;
      287:  183:  state->phase = 0;
      287:  184:  state->numActions = 1;
      287:  185:  state->numBuys = 1;
      287:  186:  state->playedCardCount = 0;
      287:  187:  state->whoseTurn = 0;
      287:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     3444:  192:  for (it = 0; it < 5; it++){
     1435:  193:    drawCard(state->whoseTurn, state);
     1435:  194:  }
        -:  195:
      287:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
      287:  198:  return 0;
      287:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     1149:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     1149:  209:  if (state->deckCount[player] < 1)
       72:  210:    return -1;
     1077:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    28646:  214:  while (state->deckCount[player] > 0) {
    13246:  215:    card = floor(Random() * state->deckCount[player]);
    13246:  216:    newDeck[newDeckPos] = state->deck[player][card];
    13246:  217:    newDeckPos++;
   117594:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    45551:  219:      state->deck[player][i] = state->deck[player][i+1];
    45551:  220:    }
    13246:  221:    state->deckCount[player]--;
        -:  222:  }
    28646:  223:  for (i = 0; i < newDeckPos; i++) {
    13246:  224:    state->deck[player][i] = newDeck[i];
    13246:  225:    state->deckCount[player]++;
    13246:  226:  }
        -:  227:
     1077:  228:  return 0;
     1149:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
     1466:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
     1466:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
     1466:  243:  if ( state->numActions < 1 )
        -:  244:    {
     1217:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
      249:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
      494:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
        4:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
      245:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
      245:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
      245:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
      245:  269:  return 0;
     1466:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
     1139:  280:  who = state->whoseTurn;
        -:  281:
     1139:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
     1139:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
     1139:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
     1139:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
     1139:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  298:  
     1139:  299:    state->coins = (state->coins) - (getCost(supplyPos));
     1139:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
     1139:  308:  return 0;
     1139:  309:}
        -:  310:
        -:  311:int numHandCards(struct gameState *state) {
     8955:  312:  return state->handCount[ whoseTurn(state) ];
        -:  313:}
        -:  314:
        -:  315:int handCard(int handPos, struct gameState *state) {
    18023:  316:  int currentPlayer = whoseTurn(state);
    18023:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
        -:  320:int supplyCount(int card, struct gameState *state) {
     2440:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
        -:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
    #####:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
    #####:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
    #####:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
        -:  346:int whoseTurn(struct gameState *state) {
    29650:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
        -:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
     1160:  353:  int currentPlayer = whoseTurn(state);
        -:  354:  
        -:  355:  //Discard hand
    14970:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
     6325:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     6325:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
     6325:  359:  }
     1160:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
     1160:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
      588:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
      588:  365:  }
        -:  366:  else{
      572:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
     1160:  370:  state->outpostPlayed = 0;
     1160:  371:  state->phase = 0;
     1160:  372:  state->numActions = 1;
     1160:  373:  state->coins = 0;
     1160:  374:  state->numBuys = 1;
     1160:  375:  state->playedCardCount = 0;
     1160:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    13920:  380:  for (k = 0; k < 5; k++){
     5800:  381:    drawCard(state->whoseTurn, state);//Draw a card
     5800:  382:  }
        -:  383:
        -:  384:  //Update money
     1160:  385:  updateCoins(state->whoseTurn, state , 0);
        -:  386:
     1160:  387:  return 0;
        -:  388:}
        -:  389:
        -:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
     1318:  395:  if (state->supplyCount[province] == 0)
        -:  396:    {
       74:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
     1244:  401:  j = 0;
    64688:  402:  for (i = 0; i < 25; i++)
        -:  403:    {
    31100:  404:      if (state->supplyCount[i] == 0)
        -:  405:	{
      126:  406:	  j++;
      126:  407:	}
    31100:  408:    }
     1244:  409:  if ( j >= 3)
        -:  410:    {
       42:  411:      return 1;
        -:  412:    }
        -:  413:
     1202:  414:  return 0;
     1318:  415:}
        -:  416:
        -:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
       64:  420:  int score = 0;
        -:  421:  //score from hand
      448:  422:  for (i = 0; i < state->handCount[player]; i++)
        -:  423:    {
      160:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
      180:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
      160:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
      177:  427:      if (state->hand[player][i] == province) { score = score + 6; };
      160:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
      160:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      160:  430:    }
        -:  431:
        -:  432:  //score from discard
     1398:  433:  for (i = 0; i < state->discardCount[player]; i++)
        -:  434:    {
      635:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
      702:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
      635:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
      752:  438:      if (state->discard[player][i] == province) { score = score + 6; };
      635:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
      635:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  441:    }
        -:  442:
        -:  443:  //score from deck
     1398:  444:  for (i = 0; i < state->discardCount[player]; i++)
        -:  445:    {
      670:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
      691:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
      635:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
      719:  449:      if (state->deck[player][i] == province) { score = score + 6; };
      635:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
      635:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  452:    }
        -:  453:
       64:  454:  return score;
        -:  455:}
        -:  456:
        -:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
        -:  468:	{
    #####:  469:	  players[i] = -9999;
    #####:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
        -:  474:	}
    #####:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
        -:  482:	{
    #####:  483:	  j = i;
    #####:  484:	}
    #####:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
        -:  493:	{
    #####:  494:	  players[i]++;
    #####:  495:	}
    #####:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
        -:  503:	{
    #####:  504:	  j = i;
    #####:  505:	}
    #####:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
        -:  513:	{
    #####:  514:	  players[i] = 1;
    #####:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
    #####:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
        -:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     8238:  528:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    14786:  533:    for (i = 0; i < state->discardCount[player];i++){
     6946:  534:      state->deck[player][i] = state->discard[player][i];
     6946:  535:      state->discard[player][i] = -1;
     6946:  536:    }
        -:  537:
      447:  538:    state->deckCount[player] = state->discardCount[player];
      447:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
      447:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
      447:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
      447:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
      447:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
      447:  559:    if (deckCounter == 0)
    #####:  560:      return -1;
        -:  561:
      447:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      447:  563:    state->deckCount[player]--;
      447:  564:    state->handCount[player]++;//Increment hand count
      447:  565:  }
        -:  566:
        -:  567:  else{
     7791:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     7791:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     7791:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     7791:  576:    state->deckCount[player]--;
     7791:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     8238:  580:  return 0;
     8238:  581:}
        -:  582:
        -:  583:int getCost(int cardNumber)
        -:  584:{
     2306:  585:  switch( cardNumber ) 
        -:  586:    {
        -:  587:    case curse:
       10:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
      512:  594:      return 8;
        -:  595:    case copper:
       14:  596:      return 0;
        -:  597:    case silver:
      888:  598:      return 3;
        -:  599:    case gold:
      626:  600:      return 6;
        -:  601:    case adventurer:
      128:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
      128:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
     2306:  644:}
        -:  645:
        -:  646:
        -:  647:void adventurerEffect(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand[], int z)
        -:  648:{
     1654:  649:  while(drawntreasure<=2){
      614:  650:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
       30:  651:	  shuffle(currentPlayer, state);
       30:  652:	}
      614:  653:	drawCard(currentPlayer, state);
      614:  654:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     1077:  655:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
      497:  656:	  drawntreasure++;
        -:  657:	else{
      117:  658:	  temphand[z]=cardDrawn;
      117:  659:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
      117:  660:	  z++;
        -:  661:	}
        -:  662:      }
      660:  663:      while(z-1>=0){
      117:  664:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
      117:  665:	z=z-1;
        -:  666:      }
      213:  667:}
        -:  668:
        -:  669:void smithyEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  670:{
        -:  671:  //+3 Cards
      672:  672:      for (int i = 1; i < 3; i++)
        -:  673:	{
      244:  674:	  drawCard(currentPlayer, state);
      244:  675:	}
        -:  676:			
        -:  677:      //discard card from hand
       92:  678:      discardCard(handPos, currentPlayer, state, 0);
       92:  679:}
        -:  680:
        -:  681:void councilRoomEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  682:{
        -:  683:  //+4 Cards
      260:  684:      for (int i = 0; i < 4; i++)
        -:  685:	{
      104:  686:	  drawCard(currentPlayer, state);
      104:  687:	}
        -:  688:			
        -:  689:      //+1 Buy
       26:  690:      state->numBuys++;
        -:  691:			
        -:  692:      //Each other player draws a card
      156:  693:      for (int i = 0; i < state->numPlayers; i++)
        -:  694:	{
       52:  695:	  if ( i == currentPlayer )
        -:  696:	    {
       26:  697:	      drawCard(i, state);
       26:  698:	    }
       52:  699:	}
        -:  700:			
        -:  701:      //put played card in played card pile
       26:  702:      discardCard(handPos, currentPlayer, state, 0);
       26:  703:}
        -:  704:
        -:  705:void feastEffect(struct gameState *state, int currentPlayer, int temphand[], int choice1, int x)
        -:  706:{
        -:  707:  //gain card with cost up to 5
        -:  708:      //Backup hand
    #####:  709:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  710:	      temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  711:	      state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  712:      }
        -:  713:      //Backup hand
        -:  714:
        -:  715:      //Update Coins for Buy
    #####:  716:      updateCoins(currentPlayer, state, 5);
    #####:  717:      x = 1;//Condition to loop on
    #####:  718:      while( x == 1) {//Buy one card
    #####:  719:	      if (supplyCount(choice1, state) <= 0){
        -:  720:	        if (DEBUG)
        -:  721:	          printf("None of that card left, sorry!\n");
        -:  722:
        -:  723:	        if (DEBUG){
        -:  724:	          printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  725:	        }
    #####:  726:	      }
    #####:  727:	      else if (state->coins < getCost(choice1)){
    #####:  728:	        printf("That card is too expensive!\n");
        -:  729:
        -:  730:	        if (DEBUG){
        -:  731:	          printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  732:	        }
    #####:  733:	      }
        -:  734:	      else{
        -:  735:
        -:  736:	        if (DEBUG){
        -:  737:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  738:	        }
        -:  739:
    #####:  740:	        gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  741:	        x = 0;//No more buying cards
        -:  742:
        -:  743:	        if (DEBUG){
        -:  744:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  745:	        }
        -:  746:
        -:  747:	      }
        -:  748:      }     
        -:  749:
        -:  750:      //Reset Hand
    #####:  751:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  752:	      state->hand[currentPlayer][i] = temphand[i];
    #####:  753:	      temphand[i] = -1;
    #####:  754:      }
    #####:  755:}
        -:  756:
        -:  757:int mineEffect(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int j)
        -:  758:{
       14:  759:  int result = 0;
       14:  760:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  761:
       28:  762:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  763:	    {
    #####:  764:        result = -1;
        -:  765:	      //return -1;
    #####:  766:	    }
        -:  767:		
       28:  768:      if (choice2 > treasure_map || choice2 < curse)
        -:  769:	    {
    #####:  770:        result = -1;
        -:  771:	      //return -1;
    #####:  772:	    }
        -:  773:
       14:  774:      if ( (getCost(state->hand[currentPlayer][choice1]) + 4) > getCost(choice2) )
        -:  775:	    {
       14:  776:        result = -1;
        -:  777:	      //return -1;
       14:  778:	    }
        -:  779:
       14:  780:      gainCard(choice2, state, 2, currentPlayer);
        -:  781:
        -:  782:      //discard card from hand
       14:  783:      discardCard(handPos, currentPlayer, state, 0);
        -:  784:
        -:  785:      //discard trashed card
       56:  786:      for (int i = 0; i < state->handCount[currentPlayer]; i++)
        -:  787:	    {
       28:  788:	      if (state->hand[currentPlayer][i] == j)
        -:  789:	      {
       14:  790:	        discardCard(i, currentPlayer, state, 0);			
       14:  791:	        break;
        -:  792:	      }
       14:  793:	    }
        -:  794:			
       14:  795:      return result;
        -:  796:}
        -:  797:
        -:  798:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  799:{
        -:  800:  int i;
14397326483292946559:  801:  int j = 0;
        -:  802:  int k;
14397326483292946559:  803:  int x = 0;
        -:  804:  int index;
        -:  805:  int result;
14397326483292946559:  806:  int currentPlayer = whoseTurn(state);
14397326483292946559:  807:  int nextPlayer = currentPlayer + 1;
        -:  808:
14397326483292946559:  809:  int tributeRevealedCards[2] = {-1, -1};
        -:  810:  int temphand[MAX_HAND];// moved above the if statement
14397326483292946559:  811:  int drawntreasure=0;
14397326483292946559:  812:  int cardDrawn=0;
14397326483292946559:  813:  int z = 0;// this is the counter for the temp hand
14397326483292946559:  814:  if (nextPlayer > (state->numPlayers - 1)){
  6582881:  815:    nextPlayer = 0;
  6582881:  816:  }
        -:  817:  
        -:  818:	
        -:  819:  //uses switch to select card and perform actions
3352292577943071122:  820:  switch( card ) 
        -:  821:    {
        -:  822:    case adventurer:
474366694533:  823:      adventurerEffect(drawntreasure, state, currentPlayer, cardDrawn, temphand, z);
474366694533:  824:      return 0;
        -:  825:			
        -:  826:    case council_room:
72057594037927962:  827:      councilRoomEffect(state, currentPlayer, handPos);
72057594037927962:  828:      return 0;
        -:  829:			
        -:  830:    case feast:
68719476743:  831:      feastEffect(state, currentPlayer, temphand, choice1,x);
68719476743:  832:      return 0;
        -:  833:			
        -:  834:    case gardens:
17424526879:  835:      return -1;
        -:  836:			
        -:  837:    case mine:
7738139929303872884:  838:      result = mineEffect(state, currentPlayer, choice1, choice2, handPos, j);
7738139929303872884:  839:      return result;
        -:  840:			
        -:  841:    case remodel:
72058094107324227:  842:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  843:
72058094107324227:  844:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  845:	{
73014444037:  846:	  return -1;
        -:  847:	}
        -:  848:
9172086132:  849:      gainCard(choice2, state, 0, currentPlayer);
        -:  850:
        -:  851:      //discard card from hand
9172086132:  852:      discardCard(handPos, currentPlayer, state, 0);
        -:  853:
        -:  854:      //discard trashed card
103145724687375321:  855:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  856:	{
93224767193:  857:	  if (state->hand[currentPlayer][i] == j)
        -:  858:	    {
8525144140093551465:  859:	      discardCard(i, currentPlayer, state, 0);			
8525144140093551465:  860:	      break;
        -:  861:	    }
    29285:  862:	}
        -:  863:
        -:  864:
6217793866309828627:  865:      return 0;
        -:  866:		
        -:  867:    case smithy:
8245918788311056415:  868:      smithyEffect(state, currentPlayer, handPos);
8245918788311056415:  869:      return 0;
        -:  870:		
        -:  871:    case village:
        -:  872:      //+1 Card
1919895156:  873:      drawCard(currentPlayer, state);
        -:  874:			
        -:  875:      //+2 Actions
1919895156:  876:      state->numActions = state->numActions + 2;
        -:  877:			
        -:  878:      //discard played card from hand
1919895156:  879:      discardCard(handPos, currentPlayer, state, 0);
1919895156:  880:      return 0;
        -:  881:		
        -:  882:    case baron:
72057679937273862:  883:      state->numBuys++;//Increase buys by 1!
72057679937273862:  884:      if (choice1 > 0){//Boolean true or going to discard an estate
16919086439:  885:	int p = 0;//Iterator for hand!
16919086439:  886:	int card_not_discarded = 1;//Flag for discard set!
7308900660905877056:  887:	while(card_not_discarded){
14700501649139433493:  888:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
7166187310294237187:  889:	    state->coins += 4;//Add 4 coins to the amount of coins
7166187310294237187:  890:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
7166187310294237187:  891:	    state->discardCount[currentPlayer]++;
7194460570033353316:  892:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  893:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  894:	    }
    #####:  895:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  896:	    state->handCount[currentPlayer]--;
    #####:  897:	    card_not_discarded = 0;//Exit the loop
    #####:  898:	  }
    #####:  899:	  else if (p > state->handCount[currentPlayer]){
        -:  900:	    if(DEBUG) {
        -:  901:	      printf("No estate cards in your hand, invalid choice\n");
        -:  902:	      printf("Must gain an estate if there are any\n");
        -:  903:	    }
    #####:  904:	    if (supplyCount(estate, state) > 0){
    #####:  905:	      gainCard(estate, state, 0, currentPlayer);
    #####:  906:	      state->supplyCount[estate]--;//Decrement estates
    #####:  907:	      if (supplyCount(estate, state) == 0){
    #####:  908:		isGameOver(state);
    #####:  909:	      }
    #####:  910:	    }
    #####:  911:	    card_not_discarded = 0;//Exit the loop
    #####:  912:	  }
        -:  913:			    
        -:  914:	  else{
    #####:  915:	    p++;//Next card
        -:  916:	  }
        -:  917:	}
    #####:  918:      }
        -:  919:			    
        -:  920:      else{
    #####:  921:	if (supplyCount(estate, state) > 0){
    #####:  922:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  923:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  924:	  if (supplyCount(estate, state) == 0){
    #####:  925:	    isGameOver(state);
    #####:  926:	  }
    #####:  927:	}
        -:  928:      }
        -:  929:	    
        -:  930:      
    #####:  931:      return 0;
        -:  932:		
        -:  933:    case great_hall:
        -:  934:      //+1 Card
    #####:  935:      drawCard(currentPlayer, state);
        -:  936:			
        -:  937:      //+1 Actions
    #####:  938:      state->numActions++;
        -:  939:			
        -:  940:      //discard card from hand
    #####:  941:      discardCard(handPos, currentPlayer, state, 0);
    #####:  942:      return 0;
        -:  943:		
        -:  944:    case minion:
        -:  945:      //+1 action
    #####:  946:      state->numActions++;
        -:  947:			
        -:  948:      //discard card from hand
    #####:  949:      discardCard(handPos, currentPlayer, state, 0);
        -:  950:			
    #####:  951:      if (choice1)		//+2 coins
        -:  952:	{
    #####:  953:	  state->coins = state->coins + 2;
    #####:  954:	}
        -:  955:			
    #####:  956:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  957:	{
        -:  958:	  //discard hand
    #####:  959:	  while(numHandCards(state) > 0)
        -:  960:	    {
    #####:  961:	      discardCard(handPos, currentPlayer, state, 0);
        -:  962:	    }
        -:  963:				
        -:  964:	  //draw 4
    #####:  965:	  for (i = 0; i < 4; i++)
        -:  966:	    {
    #####:  967:	      drawCard(currentPlayer, state);
    #####:  968:	    }
        -:  969:				
        -:  970:	  //other players discard hand and redraw if hand size > 4
    #####:  971:	  for (i = 0; i < state->numPlayers; i++)
        -:  972:	    {
    #####:  973:	      if (i != currentPlayer)
        -:  974:		{
    #####:  975:		  if ( state->handCount[i] > 4 )
        -:  976:		    {
        -:  977:		      //discard hand
    #####:  978:		      while( state->handCount[i] > 0 )
        -:  979:			{
    #####:  980:			  discardCard(handPos, i, state, 0);
        -:  981:			}
        -:  982:							
        -:  983:		      //draw 4
    #####:  984:		      for (j = 0; j < 4; j++)
        -:  985:			{
    #####:  986:			  drawCard(i, state);
    #####:  987:			}
    #####:  988:		    }
    #####:  989:		}
    #####:  990:	    }
        -:  991:				
    #####:  992:	}
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case steward:
    #####:  996:      if (choice1 == 1)
        -:  997:	{
        -:  998:	  //+2 cards
    #####:  999:	  drawCard(currentPlayer, state);
    #####: 1000:	  drawCard(currentPlayer, state);
    #####: 1001:	}
    #####: 1002:      else if (choice1 == 2)
        -: 1003:	{
        -: 1004:	  //+2 coins
    #####: 1005:	  state->coins = state->coins + 2;
    #####: 1006:	}
        -: 1007:      else
        -: 1008:	{
        -: 1009:	  //trash 2 cards in hand
    #####: 1010:	  discardCard(choice2, currentPlayer, state, 1);
    #####: 1011:	  discardCard(choice3, currentPlayer, state, 1);
        -: 1012:	}
        -: 1013:			
        -: 1014:      //discard card from hand
    #####: 1015:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1016:      return 0;
        -: 1017:		
        -: 1018:    case tribute:
    #####: 1019:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1020:	if (state->deckCount[nextPlayer] > 0){
    #####: 1021:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1022:	  state->deckCount[nextPlayer]--;
    #####: 1023:	}
    #####: 1024:	else if (state->discardCount[nextPlayer] > 0){
    #####: 1025:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1026:	  state->discardCount[nextPlayer]--;
    #####: 1027:	}
        -: 1028:	else{
        -: 1029:	  //No Card to Reveal
        -: 1030:	  if (DEBUG){
        -: 1031:	    printf("No cards to reveal\n");
        -: 1032:	  }
        -: 1033:	}
    #####: 1034:      }
        -: 1035:	    
        -: 1036:      else{
    #####: 1037:	if (state->deckCount[nextPlayer] == 0){
    #####: 1038:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1039:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1040:	    state->deckCount[nextPlayer]++;
    #####: 1041:	    state->discard[nextPlayer][i] = -1;
    #####: 1042:	    state->discardCount[nextPlayer]--;
    #####: 1043:	  }
        -: 1044:			    
    #####: 1045:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####: 1046:	} 
    #####: 1047:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1048:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1049:	state->deckCount[nextPlayer]--;
    #####: 1050:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
        -: 1053:      }    
        -: 1054:		       
    #####: 1055:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1056:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1057:	state->playedCardCount++;
    #####: 1058:	tributeRevealedCards[1] = -1;
    #####: 1059:      }
        -: 1060:
    #####: 1061:      for (i = 0; i <= 2; i ++){
    #####: 1062:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1063:	  state->coins += 2;
    #####: 1064:	}
        -: 1065:		    
    #####: 1066:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1067:	  drawCard(currentPlayer, state);
    #####: 1068:	  drawCard(currentPlayer, state);
    #####: 1069:	}
        -: 1070:	else{//Action Card
    #####: 1071:	  state->numActions = state->numActions + 2;
        -: 1072:	}
    #####: 1073:      }
        -: 1074:	    
    #####: 1075:      return 0;
        -: 1076:		
        -: 1077:    case ambassador:
    #####: 1078:      j = 0;		//used to check if player has enough cards to discard
        -: 1079:
    #####: 1080:      if (choice2 > 2 || choice2 < 0)
        -: 1081:	{
    #####: 1082:	  return -1;				
        -: 1083:	}
        -: 1084:
    #####: 1085:      if (choice1 == handPos)
        -: 1086:	{
    #####: 1087:	  return -1;
        -: 1088:	}
        -: 1089:
    #####: 1090:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1091:	{
    #####: 1092:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1093:	    {
    #####: 1094:	      j++;
    #####: 1095:	    }
    #####: 1096:	}
    #####: 1097:      if (j < choice2)
        -: 1098:	{
    #####: 1099:	  return -1;				
        -: 1100:	}
        -: 1101:
        -: 1102:      if (DEBUG) 
        -: 1103:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1104:
        -: 1105:      //increase supply count for choosen card by amount being discarded
    #####: 1106:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1107:			
        -: 1108:      //each other player gains a copy of revealed card
    #####: 1109:      for (i = 0; i < state->numPlayers; i++)
        -: 1110:	{
    #####: 1111:	  if (i != currentPlayer)
        -: 1112:	    {
    #####: 1113:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1114:	    }
    #####: 1115:	}
        -: 1116:
        -: 1117:      //discard played card from hand
    #####: 1118:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1119:
        -: 1120:      //trash copies of cards returned to supply
    #####: 1121:      for (j = 0; j < choice2; j++)
        -: 1122:	{
    #####: 1123:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1124:	    {
    #####: 1125:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1126:		{
    #####: 1127:		  discardCard(i, currentPlayer, state, 1);
    #####: 1128:		  break;
        -: 1129:		}
    #####: 1130:	    }
    #####: 1131:	}			
        -: 1132:
    #####: 1133:      return 0;
        -: 1134:		
        -: 1135:    case cutpurse:
        -: 1136:
    #####: 1137:      updateCoins(currentPlayer, state, 2);
    #####: 1138:      for (i = 0; i < state->numPlayers; i++)
        -: 1139:	{
    #####: 1140:	  if (i != currentPlayer)
        -: 1141:	    {
    #####: 1142:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1143:		{
    #####: 1144:		  if (state->hand[i][j] == copper)
        -: 1145:		    {
    #####: 1146:		      discardCard(j, i, state, 0);
    #####: 1147:		      break;
        -: 1148:		    }
    #####: 1149:		  if (j == state->handCount[i])
        -: 1150:		    {
    #####: 1151:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1152:			{
        -: 1153:			  if (DEBUG)
        -: 1154:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1155:			}	
    #####: 1156:		      break;
        -: 1157:		    }		
    #####: 1158:		}
        -: 1159:					
    #####: 1160:	    }
        -: 1161:				
    #####: 1162:	}				
        -: 1163:
        -: 1164:      //discard played card from hand
    #####: 1165:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1166:
    #####: 1167:      return 0;
        -: 1168:
        -: 1169:		
        -: 1170:    case embargo: 
        -: 1171:      //+2 Coins
    #####: 1172:      state->coins = state->coins + 2;
        -: 1173:			
        -: 1174:      //see if selected pile is in play
    #####: 1175:      if ( state->supplyCount[choice1] == -1 )
        -: 1176:	{
    #####: 1177:	  return -1;
        -: 1178:	}
        -: 1179:			
        -: 1180:      //add embargo token to selected supply pile
    #####: 1181:      state->embargoTokens[choice1]++;
        -: 1182:			
        -: 1183:      //trash card
    #####: 1184:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1185:      return 0;
        -: 1186:		
        -: 1187:    case outpost:
        -: 1188:      //set outpost flag
    #####: 1189:      state->outpostPlayed++;
        -: 1190:			
        -: 1191:      //discard card
    #####: 1192:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1193:      return 0;
        -: 1194:		
        -: 1195:    case salvager:
        -: 1196:      //+1 buy
    #####: 1197:      state->numBuys++;
        -: 1198:			
    #####: 1199:      if (choice1)
        -: 1200:	{
        -: 1201:	  //gain coins equal to trashed card
    #####: 1202:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1203:	  //trash card
    #####: 1204:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1205:	}
        -: 1206:			
        -: 1207:      //discard card
    #####: 1208:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1209:      return 0;
        -: 1210:		
        -: 1211:    case sea_hag:
    #####: 1212:      for (i = 0; i < state->numPlayers; i++){
    #####: 1213:	if (i != currentPlayer){
    #####: 1214:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1215:	  state->discardCount[i]++;
    #####: 1216:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1217:	}
    #####: 1218:      }
    #####: 1219:      return 0;
        -: 1220:		
        -: 1221:    case treasure_map:
        -: 1222:      //search hand for another treasure_map
    #####: 1223:      index = -1;
    #####: 1224:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1225:	{
    #####: 1226:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1227:	    {
    #####: 1228:	      index = i;
    #####: 1229:	      break;
        -: 1230:	    }
    #####: 1231:	}
    #####: 1232:      if (index > -1)
        -: 1233:	{
        -: 1234:	  //trash both treasure cards
    #####: 1235:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1236:	  discardCard(index, currentPlayer, state, 1);
        -: 1237:
        -: 1238:	  //gain 4 Gold cards
    #####: 1239:	  for (i = 0; i < 4; i++)
        -: 1240:	    {
    #####: 1241:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1242:	    }
        -: 1243:				
        -: 1244:	  //return success
    #####: 1245:	  return 1;
        -: 1246:	}
        -: 1247:			
        -: 1248:      //no second treasure_map found in hand
    #####: 1249:      return -1;
        -: 1250:    }
        -: 1251:	
    #####: 1252:  return -1;
      360: 1253:}
        -: 1254:
        -: 1255:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1256:{
        -: 1257:	
        -: 1258:  //if card is not trashed, added to Played pile 
      161: 1259:  if (trashFlag < 1)
        -: 1260:    {
        -: 1261:      //add card to played pile
      161: 1262:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      161: 1263:      state->playedCardCount++;
      161: 1264:    }
        -: 1265:	
        -: 1266:  //set played card to -1
      161: 1267:  state->hand[currentPlayer][handPos] = -1;
        -: 1268:	
        -: 1269:  //remove card from player's hand
      161: 1270:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1271:    {
        -: 1272:      //reduce number of cards in hand
    #####: 1273:      state->handCount[currentPlayer]--;
    #####: 1274:    }
      161: 1275:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1276:    {
        -: 1277:      //reduce number of cards in hand
    #####: 1278:      state->handCount[currentPlayer]--;
    #####: 1279:    }
        -: 1280:  else 	
        -: 1281:    {
        -: 1282:      //replace discarded card with last card in hand
      161: 1283:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1284:      //set last card to -1
      161: 1285:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1286:      //reduce number of cards in hand
      161: 1287:      state->handCount[currentPlayer]--;
        -: 1288:    }
        -: 1289:	
      161: 1290:  return 0;
        -: 1291:}
        -: 1292:
        -: 1293:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1294:{
        -: 1295:  //Note: supplyPos is enum of choosen card
        -: 1296:	
        -: 1297:  //check if supply pile is empty (0) or card is not used in game (-1)
     1301: 1298:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1299:    {
       40: 1300:      return -1;
        -: 1301:    }
        -: 1302:	
        -: 1303:  //added card for [whoseTurn] current player:
        -: 1304:  // toFlag = 0 : add to discard
        -: 1305:  // toFlag = 1 : add to deck
        -: 1306:  // toFlag = 2 : add to hand
        -: 1307:
     1261: 1308:  if (toFlag == 1)
        -: 1309:    {
       27: 1310:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
       27: 1311:      state->deckCount[player]++;
       27: 1312:    }
     1234: 1313:  else if (toFlag == 2)
        -: 1314:    {
       41: 1315:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
       41: 1316:      state->handCount[player]++;
       41: 1317:    }
        -: 1318:  else
        -: 1319:    {
     1193: 1320:      state->discard[player][ state->discardCount[player] ] = supplyPos;
     1193: 1321:      state->discardCount[player]++;
        -: 1322:    }
        -: 1323:	
        -: 1324:  //decrease number in supply pile
     1261: 1325:  state->supplyCount[supplyPos]--;
        -: 1326:	 
     1261: 1327:  return 0;
     1301: 1328:}
        -: 1329:
        -: 1330:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1331:{
        -: 1332:  int i;
        -: 1333:	
        -: 1334:  //reset coin count
     1860: 1335:  state->coins = 0;
        -: 1336:
        -: 1337:  //add coins for each Treasure card in player's hand
    22530: 1338:  for (i = 0; i < state->handCount[player]; i++)
        -: 1339:    {
     9405: 1340:      if (state->hand[player][i] == copper)
        -: 1341:	{
     4453: 1342:	  state->coins += 1;
     4453: 1343:	}
     4952: 1344:      else if (state->hand[player][i] == silver)
        -: 1345:	{
     1835: 1346:	  state->coins += 2;
     1835: 1347:	}
     3117: 1348:      else if (state->hand[player][i] == gold)
        -: 1349:	{
      605: 1350:	  state->coins += 3;
      605: 1351:	}	
     9405: 1352:    }	
        -: 1353:
        -: 1354:  //add bonus
     1860: 1355:  state->coins += bonus;
        -: 1356:
     1860: 1357:  return 0;
        -: 1358:}
        -: 1359:
        -: 1360:
        -: 1361://end of dominion.c
        -: 1362:
cardtest2.c:
Starting tests for smithyEffect()...

TEST: Player 0 gains 3 cards
Actual: 6
Expected: 7
FAILED

TEST: Player 0 gains 3 cards from his own pile
Actual: 3
Expected: 2
FAILED

TEST: No change to victory card piles
Province Pile
Actual: 8
Expected: 8
PASSED

Duchy Pile
Actual: 8
Expected: 8
PASSED

Estate Pile
Actual: 8
Expected: 8
PASSED

TEST: No change to kingdom card piles
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED

TEST: Player 1 was not affected
Hand Count
Actual: 0
Expected: 0
PASSED

Deck Count
Actual: 10
Expected: 10
PASSED

TEST(S) FAILED
2 of 17 tests failed!
File 'cardtest2.c'
Lines executed:98.41% of 63
cardtest2.c:creating 'cardtest2.c.gcov'

File 'dominion.c'
Lines executed:52.59% of 656
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:259
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    23935:    9:  if (*(int*)a > *(int*)b)
     4441:   10:    return 1;
    19494:   11:  if (*(int*)a < *(int*)b)
     8194:   12:    return -1;
    11300:   13:  return 0;
    23935:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      288:   44:  SelectStream(1);
      288:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
      576:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      288:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     6336:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    63360:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    54720:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    28800:   65:        }
     2880:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      288:   73:  if (numPlayers == 2)
        -:   74:    {
      288:   75:      state->supplyCount[curse] = 10;
      288:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      288:   87:  if (numPlayers == 2)
        -:   88:    {
      288:   89:      state->supplyCount[estate] = 8;
      288:   90:      state->supplyCount[duchy] = 8;
      288:   91:      state->supplyCount[province] = 8;
      288:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      288:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      288:  102:  state->supplyCount[silver] = 40;
      288:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    12096:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    95040:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    44640:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     5505:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
      543:  115:		  if (numPlayers == 2){ 
      543:  116:		    state->supplyCount[i] = 8; 
      543:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
      543:  119:		}
        -:  120:	      else
        -:  121:		{
     2337:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     2880:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    41760:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    41760:  130:	}
        -:  131:
     5760:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     1728:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
      576:  140:      state->deckCount[i] = 0;
     4608:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
     1728:  143:	  state->deck[i][j] = estate;
     1728:  144:	  state->deckCount[i]++;
     1728:  145:	}
     9216:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
     4032:  148:	  state->deck[i][j] = copper;
     4032:  149:	  state->deckCount[i]++;		
     4032:  150:	}
      576:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     1728:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
      576:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
      576:  160:    }
        -:  161:
        -:  162:  //draw player hands
     1728:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      576:  166:      state->handCount[i] = 0;
      576:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
      576:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    16128:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
     7776:  178:      state->embargoTokens[i] = 0;
     7776:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      288:  182:  state->outpostPlayed = 0;
      288:  183:  state->phase = 0;
      288:  184:  state->numActions = 1;
      288:  185:  state->numBuys = 1;
      288:  186:  state->playedCardCount = 0;
      288:  187:  state->whoseTurn = 0;
      288:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     3456:  192:  for (it = 0; it < 5; it++){
     1440:  193:    drawCard(state->whoseTurn, state);
     1440:  194:  }
        -:  195:
      288:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
      288:  198:  return 0;
      288:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     1151:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     1151:  209:  if (state->deckCount[player] < 1)
       72:  210:    return -1;
     1079:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    28690:  214:  while (state->deckCount[player] > 0) {
    13266:  215:    card = floor(Random() * state->deckCount[player]);
    13266:  216:    newDeck[newDeckPos] = state->deck[player][card];
    13266:  217:    newDeckPos++;
   117746:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    45607:  219:      state->deck[player][i] = state->deck[player][i+1];
    45607:  220:    }
    13266:  221:    state->deckCount[player]--;
        -:  222:  }
    28690:  223:  for (i = 0; i < newDeckPos; i++) {
    13266:  224:    state->deck[player][i] = newDeck[i];
    13266:  225:    state->deckCount[player]++;
    13266:  226:  }
        -:  227:
     1079:  228:  return 0;
     1151:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
     1466:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
     1466:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
     1466:  243:  if ( state->numActions < 1 )
        -:  244:    {
     1217:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
      249:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
      494:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
        4:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
      245:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
      245:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
      245:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
      245:  269:  return 0;
     1466:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
     1139:  280:  who = state->whoseTurn;
        -:  281:
     1139:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
     1139:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
     1139:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
     1139:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
     1139:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  298:  
     1139:  299:    state->coins = (state->coins) - (getCost(supplyPos));
     1139:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
     1139:  308:  return 0;
     1139:  309:}
        -:  310:
        -:  311:int numHandCards(struct gameState *state) {
     8955:  312:  return state->handCount[ whoseTurn(state) ];
        -:  313:}
        -:  314:
        -:  315:int handCard(int handPos, struct gameState *state) {
    18023:  316:  int currentPlayer = whoseTurn(state);
    18023:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
        -:  320:int supplyCount(int card, struct gameState *state) {
     2440:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
        -:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
    #####:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
    #####:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
    #####:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
        -:  346:int whoseTurn(struct gameState *state) {
    29651:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
        -:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
     1160:  353:  int currentPlayer = whoseTurn(state);
        -:  354:  
        -:  355:  //Discard hand
    14970:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
     6325:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     6325:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
     6325:  359:  }
     1160:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
     1160:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
      588:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
      588:  365:  }
        -:  366:  else{
      572:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
     1160:  370:  state->outpostPlayed = 0;
     1160:  371:  state->phase = 0;
     1160:  372:  state->numActions = 1;
     1160:  373:  state->coins = 0;
     1160:  374:  state->numBuys = 1;
     1160:  375:  state->playedCardCount = 0;
     1160:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    13920:  380:  for (k = 0; k < 5; k++){
     5800:  381:    drawCard(state->whoseTurn, state);//Draw a card
     5800:  382:  }
        -:  383:
        -:  384:  //Update money
     1160:  385:  updateCoins(state->whoseTurn, state , 0);
        -:  386:
     1160:  387:  return 0;
        -:  388:}
        -:  389:
        -:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
     1318:  395:  if (state->supplyCount[province] == 0)
        -:  396:    {
       74:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
     1244:  401:  j = 0;
    64688:  402:  for (i = 0; i < 25; i++)
        -:  403:    {
    31100:  404:      if (state->supplyCount[i] == 0)
        -:  405:	{
      126:  406:	  j++;
      126:  407:	}
    31100:  408:    }
     1244:  409:  if ( j >= 3)
        -:  410:    {
       42:  411:      return 1;
        -:  412:    }
        -:  413:
     1202:  414:  return 0;
     1318:  415:}
        -:  416:
        -:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
       64:  420:  int score = 0;
        -:  421:  //score from hand
      448:  422:  for (i = 0; i < state->handCount[player]; i++)
        -:  423:    {
      160:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
      180:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
      160:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
      177:  427:      if (state->hand[player][i] == province) { score = score + 6; };
      160:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
      160:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      160:  430:    }
        -:  431:
        -:  432:  //score from discard
     1398:  433:  for (i = 0; i < state->discardCount[player]; i++)
        -:  434:    {
      635:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
      702:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
      635:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
      752:  438:      if (state->discard[player][i] == province) { score = score + 6; };
      635:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
      635:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  441:    }
        -:  442:
        -:  443:  //score from deck
     1398:  444:  for (i = 0; i < state->discardCount[player]; i++)
        -:  445:    {
      670:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
      691:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
      635:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
      719:  449:      if (state->deck[player][i] == province) { score = score + 6; };
      635:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
      635:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  452:    }
        -:  453:
       64:  454:  return score;
        -:  455:}
        -:  456:
        -:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
        -:  468:	{
    #####:  469:	  players[i] = -9999;
    #####:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
        -:  474:	}
    #####:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
        -:  482:	{
    #####:  483:	  j = i;
    #####:  484:	}
    #####:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
        -:  493:	{
    #####:  494:	  players[i]++;
    #####:  495:	}
    #####:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
        -:  503:	{
    #####:  504:	  j = i;
    #####:  505:	}
    #####:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
        -:  513:	{
    #####:  514:	  players[i] = 1;
    #####:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
    #####:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
        -:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     8245:  528:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    14786:  533:    for (i = 0; i < state->discardCount[player];i++){
     6946:  534:      state->deck[player][i] = state->discard[player][i];
     6946:  535:      state->discard[player][i] = -1;
     6946:  536:    }
        -:  537:
      447:  538:    state->deckCount[player] = state->discardCount[player];
      447:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
      447:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
      447:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
      447:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
      447:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
      447:  559:    if (deckCounter == 0)
    #####:  560:      return -1;
        -:  561:
      447:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      447:  563:    state->deckCount[player]--;
      447:  564:    state->handCount[player]++;//Increment hand count
      447:  565:  }
        -:  566:
        -:  567:  else{
     7798:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     7798:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     7798:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     7798:  576:    state->deckCount[player]--;
     7798:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     8245:  580:  return 0;
     8245:  581:}
        -:  582:
        -:  583:int getCost(int cardNumber)
        -:  584:{
     2306:  585:  switch( cardNumber ) 
        -:  586:    {
        -:  587:    case curse:
       10:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
      512:  594:      return 8;
        -:  595:    case copper:
       14:  596:      return 0;
        -:  597:    case silver:
      888:  598:      return 3;
        -:  599:    case gold:
      626:  600:      return 6;
        -:  601:    case adventurer:
      128:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
      128:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
     2306:  644:}
        -:  645:
        -:  646:
        -:  647:void adventurerEffect(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand[], int z)
        -:  648:{
     1654:  649:  while(drawntreasure<=2){
      614:  650:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
       30:  651:	  shuffle(currentPlayer, state);
       30:  652:	}
      614:  653:	drawCard(currentPlayer, state);
      614:  654:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     1077:  655:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
      497:  656:	  drawntreasure++;
        -:  657:	else{
      117:  658:	  temphand[z]=cardDrawn;
      117:  659:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
      117:  660:	  z++;
        -:  661:	}
        -:  662:      }
      660:  663:      while(z-1>=0){
      117:  664:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
      117:  665:	z=z-1;
        -:  666:      }
      213:  667:}
        -:  668:
        -:  669:void smithyEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  670:{
        -:  671:  //+3 Cards
      678:  672:      for (int i = 1; i < 3; i++)
        -:  673:	{
      246:  674:	  drawCard(currentPlayer, state);
      246:  675:	}
        -:  676:			
        -:  677:      //discard card from hand
       93:  678:      discardCard(handPos, currentPlayer, state, 0);
       93:  679:}
        -:  680:
        -:  681:void councilRoomEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  682:{
        -:  683:  //+4 Cards
      260:  684:      for (int i = 0; i < 4; i++)
        -:  685:	{
      104:  686:	  drawCard(currentPlayer, state);
      104:  687:	}
        -:  688:			
        -:  689:      //+1 Buy
       26:  690:      state->numBuys++;
        -:  691:			
        -:  692:      //Each other player draws a card
      156:  693:      for (int i = 0; i < state->numPlayers; i++)
        -:  694:	{
       52:  695:	  if ( i == currentPlayer )
        -:  696:	    {
       26:  697:	      drawCard(i, state);
       26:  698:	    }
       52:  699:	}
        -:  700:			
        -:  701:      //put played card in played card pile
       26:  702:      discardCard(handPos, currentPlayer, state, 0);
       26:  703:}
        -:  704:
        -:  705:void feastEffect(struct gameState *state, int currentPlayer, int temphand[], int choice1, int x)
        -:  706:{
        -:  707:  //gain card with cost up to 5
        -:  708:      //Backup hand
    #####:  709:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  710:	      temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  711:	      state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  712:      }
        -:  713:      //Backup hand
        -:  714:
        -:  715:      //Update Coins for Buy
    #####:  716:      updateCoins(currentPlayer, state, 5);
    #####:  717:      x = 1;//Condition to loop on
    #####:  718:      while( x == 1) {//Buy one card
    #####:  719:	      if (supplyCount(choice1, state) <= 0){
        -:  720:	        if (DEBUG)
        -:  721:	          printf("None of that card left, sorry!\n");
        -:  722:
        -:  723:	        if (DEBUG){
        -:  724:	          printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  725:	        }
    #####:  726:	      }
    #####:  727:	      else if (state->coins < getCost(choice1)){
    #####:  728:	        printf("That card is too expensive!\n");
        -:  729:
        -:  730:	        if (DEBUG){
        -:  731:	          printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  732:	        }
    #####:  733:	      }
        -:  734:	      else{
        -:  735:
        -:  736:	        if (DEBUG){
        -:  737:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  738:	        }
        -:  739:
    #####:  740:	        gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  741:	        x = 0;//No more buying cards
        -:  742:
        -:  743:	        if (DEBUG){
        -:  744:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  745:	        }
        -:  746:
        -:  747:	      }
        -:  748:      }     
        -:  749:
        -:  750:      //Reset Hand
    #####:  751:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  752:	      state->hand[currentPlayer][i] = temphand[i];
    #####:  753:	      temphand[i] = -1;
    #####:  754:      }
    #####:  755:}
        -:  756:
        -:  757:int mineEffect(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int j)
        -:  758:{
       14:  759:  int result = 0;
       14:  760:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  761:
       28:  762:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  763:	    {
    #####:  764:        result = -1;
        -:  765:	      //return -1;
    #####:  766:	    }
        -:  767:		
       28:  768:      if (choice2 > treasure_map || choice2 < curse)
        -:  769:	    {
    #####:  770:        result = -1;
        -:  771:	      //return -1;
    #####:  772:	    }
        -:  773:
       14:  774:      if ( (getCost(state->hand[currentPlayer][choice1]) + 4) > getCost(choice2) )
        -:  775:	    {
       14:  776:        result = -1;
        -:  777:	      //return -1;
       14:  778:	    }
        -:  779:
       14:  780:      gainCard(choice2, state, 2, currentPlayer);
        -:  781:
        -:  782:      //discard card from hand
       14:  783:      discardCard(handPos, currentPlayer, state, 0);
        -:  784:
        -:  785:      //discard trashed card
       56:  786:      for (int i = 0; i < state->handCount[currentPlayer]; i++)
        -:  787:	    {
       28:  788:	      if (state->hand[currentPlayer][i] == j)
        -:  789:	      {
       14:  790:	        discardCard(i, currentPlayer, state, 0);			
       14:  791:	        break;
        -:  792:	      }
       14:  793:	    }
        -:  794:			
       14:  795:      return result;
        -:  796:}
        -:  797:
        -:  798:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  799:{
        -:  800:  int i;
14397326483292946560:  801:  int j = 0;
        -:  802:  int k;
14397326483292946560:  803:  int x = 0;
        -:  804:  int index;
        -:  805:  int result;
14397326483292946560:  806:  int currentPlayer = whoseTurn(state);
14397326483292946560:  807:  int nextPlayer = currentPlayer + 1;
        -:  808:
14397326483292946560:  809:  int tributeRevealedCards[2] = {-1, -1};
        -:  810:  int temphand[MAX_HAND];// moved above the if statement
14397326483292946560:  811:  int drawntreasure=0;
14397326483292946560:  812:  int cardDrawn=0;
14397326483292946560:  813:  int z = 0;// this is the counter for the temp hand
14397326483292946560:  814:  if (nextPlayer > (state->numPlayers - 1)){
  6582881:  815:    nextPlayer = 0;
  6582881:  816:  }
        -:  817:  
        -:  818:	
        -:  819:  //uses switch to select card and perform actions
3352292577943071123:  820:  switch( card ) 
        -:  821:    {
        -:  822:    case adventurer:
474366694533:  823:      adventurerEffect(drawntreasure, state, currentPlayer, cardDrawn, temphand, z);
474366694533:  824:      return 0;
        -:  825:			
        -:  826:    case council_room:
72057594037927962:  827:      councilRoomEffect(state, currentPlayer, handPos);
72057594037927962:  828:      return 0;
        -:  829:			
        -:  830:    case feast:
68719476743:  831:      feastEffect(state, currentPlayer, temphand, choice1,x);
68719476743:  832:      return 0;
        -:  833:			
        -:  834:    case gardens:
17424526879:  835:      return -1;
        -:  836:			
        -:  837:    case mine:
7738139929303872884:  838:      result = mineEffect(state, currentPlayer, choice1, choice2, handPos, j);
7738139929303872884:  839:      return result;
        -:  840:			
        -:  841:    case remodel:
72058094107324227:  842:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  843:
72058094107324227:  844:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  845:	{
73014444037:  846:	  return -1;
        -:  847:	}
        -:  848:
9172086132:  849:      gainCard(choice2, state, 0, currentPlayer);
        -:  850:
        -:  851:      //discard card from hand
9172086132:  852:      discardCard(handPos, currentPlayer, state, 0);
        -:  853:
        -:  854:      //discard trashed card
103145724687375321:  855:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  856:	{
93224767193:  857:	  if (state->hand[currentPlayer][i] == j)
        -:  858:	    {
8525144140093551465:  859:	      discardCard(i, currentPlayer, state, 0);			
8525144140093551465:  860:	      break;
        -:  861:	    }
    29285:  862:	}
        -:  863:
        -:  864:
6217793866309828627:  865:      return 0;
        -:  866:		
        -:  867:    case smithy:
8245918788311056416:  868:      smithyEffect(state, currentPlayer, handPos);
8245918788311056416:  869:      return 0;
        -:  870:		
        -:  871:    case village:
        -:  872:      //+1 Card
1919895156:  873:      drawCard(currentPlayer, state);
        -:  874:			
        -:  875:      //+2 Actions
1919895156:  876:      state->numActions = state->numActions + 2;
        -:  877:			
        -:  878:      //discard played card from hand
1919895156:  879:      discardCard(handPos, currentPlayer, state, 0);
1919895156:  880:      return 0;
        -:  881:		
        -:  882:    case baron:
72057679937273862:  883:      state->numBuys++;//Increase buys by 1!
72057679937273862:  884:      if (choice1 > 0){//Boolean true or going to discard an estate
16919086439:  885:	int p = 0;//Iterator for hand!
16919086439:  886:	int card_not_discarded = 1;//Flag for discard set!
7308900660905877056:  887:	while(card_not_discarded){
14700501649139433493:  888:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
7166187310294237187:  889:	    state->coins += 4;//Add 4 coins to the amount of coins
7166187310294237187:  890:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
7166187310294237187:  891:	    state->discardCount[currentPlayer]++;
7194460570033353316:  892:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  893:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  894:	    }
    #####:  895:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  896:	    state->handCount[currentPlayer]--;
    #####:  897:	    card_not_discarded = 0;//Exit the loop
    #####:  898:	  }
    #####:  899:	  else if (p > state->handCount[currentPlayer]){
        -:  900:	    if(DEBUG) {
        -:  901:	      printf("No estate cards in your hand, invalid choice\n");
        -:  902:	      printf("Must gain an estate if there are any\n");
        -:  903:	    }
    #####:  904:	    if (supplyCount(estate, state) > 0){
    #####:  905:	      gainCard(estate, state, 0, currentPlayer);
    #####:  906:	      state->supplyCount[estate]--;//Decrement estates
    #####:  907:	      if (supplyCount(estate, state) == 0){
    #####:  908:		isGameOver(state);
    #####:  909:	      }
    #####:  910:	    }
    #####:  911:	    card_not_discarded = 0;//Exit the loop
    #####:  912:	  }
        -:  913:			    
        -:  914:	  else{
    #####:  915:	    p++;//Next card
        -:  916:	  }
        -:  917:	}
    #####:  918:      }
        -:  919:			    
        -:  920:      else{
    #####:  921:	if (supplyCount(estate, state) > 0){
    #####:  922:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  923:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  924:	  if (supplyCount(estate, state) == 0){
    #####:  925:	    isGameOver(state);
    #####:  926:	  }
    #####:  927:	}
        -:  928:      }
        -:  929:	    
        -:  930:      
    #####:  931:      return 0;
        -:  932:		
        -:  933:    case great_hall:
        -:  934:      //+1 Card
    #####:  935:      drawCard(currentPlayer, state);
        -:  936:			
        -:  937:      //+1 Actions
    #####:  938:      state->numActions++;
        -:  939:			
        -:  940:      //discard card from hand
    #####:  941:      discardCard(handPos, currentPlayer, state, 0);
    #####:  942:      return 0;
        -:  943:		
        -:  944:    case minion:
        -:  945:      //+1 action
    #####:  946:      state->numActions++;
        -:  947:			
        -:  948:      //discard card from hand
    #####:  949:      discardCard(handPos, currentPlayer, state, 0);
        -:  950:			
    #####:  951:      if (choice1)		//+2 coins
        -:  952:	{
    #####:  953:	  state->coins = state->coins + 2;
    #####:  954:	}
        -:  955:			
    #####:  956:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  957:	{
        -:  958:	  //discard hand
    #####:  959:	  while(numHandCards(state) > 0)
        -:  960:	    {
    #####:  961:	      discardCard(handPos, currentPlayer, state, 0);
        -:  962:	    }
        -:  963:				
        -:  964:	  //draw 4
    #####:  965:	  for (i = 0; i < 4; i++)
        -:  966:	    {
    #####:  967:	      drawCard(currentPlayer, state);
    #####:  968:	    }
        -:  969:				
        -:  970:	  //other players discard hand and redraw if hand size > 4
    #####:  971:	  for (i = 0; i < state->numPlayers; i++)
        -:  972:	    {
    #####:  973:	      if (i != currentPlayer)
        -:  974:		{
    #####:  975:		  if ( state->handCount[i] > 4 )
        -:  976:		    {
        -:  977:		      //discard hand
    #####:  978:		      while( state->handCount[i] > 0 )
        -:  979:			{
    #####:  980:			  discardCard(handPos, i, state, 0);
        -:  981:			}
        -:  982:							
        -:  983:		      //draw 4
    #####:  984:		      for (j = 0; j < 4; j++)
        -:  985:			{
    #####:  986:			  drawCard(i, state);
    #####:  987:			}
    #####:  988:		    }
    #####:  989:		}
    #####:  990:	    }
        -:  991:				
    #####:  992:	}
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case steward:
    #####:  996:      if (choice1 == 1)
        -:  997:	{
        -:  998:	  //+2 cards
    #####:  999:	  drawCard(currentPlayer, state);
    #####: 1000:	  drawCard(currentPlayer, state);
    #####: 1001:	}
    #####: 1002:      else if (choice1 == 2)
        -: 1003:	{
        -: 1004:	  //+2 coins
    #####: 1005:	  state->coins = state->coins + 2;
    #####: 1006:	}
        -: 1007:      else
        -: 1008:	{
        -: 1009:	  //trash 2 cards in hand
    #####: 1010:	  discardCard(choice2, currentPlayer, state, 1);
    #####: 1011:	  discardCard(choice3, currentPlayer, state, 1);
        -: 1012:	}
        -: 1013:			
        -: 1014:      //discard card from hand
    #####: 1015:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1016:      return 0;
        -: 1017:		
        -: 1018:    case tribute:
    #####: 1019:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1020:	if (state->deckCount[nextPlayer] > 0){
    #####: 1021:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1022:	  state->deckCount[nextPlayer]--;
    #####: 1023:	}
    #####: 1024:	else if (state->discardCount[nextPlayer] > 0){
    #####: 1025:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1026:	  state->discardCount[nextPlayer]--;
    #####: 1027:	}
        -: 1028:	else{
        -: 1029:	  //No Card to Reveal
        -: 1030:	  if (DEBUG){
        -: 1031:	    printf("No cards to reveal\n");
        -: 1032:	  }
        -: 1033:	}
    #####: 1034:      }
        -: 1035:	    
        -: 1036:      else{
    #####: 1037:	if (state->deckCount[nextPlayer] == 0){
    #####: 1038:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1039:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1040:	    state->deckCount[nextPlayer]++;
    #####: 1041:	    state->discard[nextPlayer][i] = -1;
    #####: 1042:	    state->discardCount[nextPlayer]--;
    #####: 1043:	  }
        -: 1044:			    
    #####: 1045:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####: 1046:	} 
    #####: 1047:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1048:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1049:	state->deckCount[nextPlayer]--;
    #####: 1050:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
        -: 1053:      }    
        -: 1054:		       
    #####: 1055:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1056:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1057:	state->playedCardCount++;
    #####: 1058:	tributeRevealedCards[1] = -1;
    #####: 1059:      }
        -: 1060:
    #####: 1061:      for (i = 0; i <= 2; i ++){
    #####: 1062:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1063:	  state->coins += 2;
    #####: 1064:	}
        -: 1065:		    
    #####: 1066:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1067:	  drawCard(currentPlayer, state);
    #####: 1068:	  drawCard(currentPlayer, state);
    #####: 1069:	}
        -: 1070:	else{//Action Card
    #####: 1071:	  state->numActions = state->numActions + 2;
        -: 1072:	}
    #####: 1073:      }
        -: 1074:	    
    #####: 1075:      return 0;
        -: 1076:		
        -: 1077:    case ambassador:
    #####: 1078:      j = 0;		//used to check if player has enough cards to discard
        -: 1079:
    #####: 1080:      if (choice2 > 2 || choice2 < 0)
        -: 1081:	{
    #####: 1082:	  return -1;				
        -: 1083:	}
        -: 1084:
    #####: 1085:      if (choice1 == handPos)
        -: 1086:	{
    #####: 1087:	  return -1;
        -: 1088:	}
        -: 1089:
    #####: 1090:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1091:	{
    #####: 1092:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1093:	    {
    #####: 1094:	      j++;
    #####: 1095:	    }
    #####: 1096:	}
    #####: 1097:      if (j < choice2)
        -: 1098:	{
    #####: 1099:	  return -1;				
        -: 1100:	}
        -: 1101:
        -: 1102:      if (DEBUG) 
        -: 1103:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1104:
        -: 1105:      //increase supply count for choosen card by amount being discarded
    #####: 1106:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1107:			
        -: 1108:      //each other player gains a copy of revealed card
    #####: 1109:      for (i = 0; i < state->numPlayers; i++)
        -: 1110:	{
    #####: 1111:	  if (i != currentPlayer)
        -: 1112:	    {
    #####: 1113:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1114:	    }
    #####: 1115:	}
        -: 1116:
        -: 1117:      //discard played card from hand
    #####: 1118:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1119:
        -: 1120:      //trash copies of cards returned to supply
    #####: 1121:      for (j = 0; j < choice2; j++)
        -: 1122:	{
    #####: 1123:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1124:	    {
    #####: 1125:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1126:		{
    #####: 1127:		  discardCard(i, currentPlayer, state, 1);
    #####: 1128:		  break;
        -: 1129:		}
    #####: 1130:	    }
    #####: 1131:	}			
        -: 1132:
    #####: 1133:      return 0;
        -: 1134:		
        -: 1135:    case cutpurse:
        -: 1136:
    #####: 1137:      updateCoins(currentPlayer, state, 2);
    #####: 1138:      for (i = 0; i < state->numPlayers; i++)
        -: 1139:	{
    #####: 1140:	  if (i != currentPlayer)
        -: 1141:	    {
    #####: 1142:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1143:		{
    #####: 1144:		  if (state->hand[i][j] == copper)
        -: 1145:		    {
    #####: 1146:		      discardCard(j, i, state, 0);
    #####: 1147:		      break;
        -: 1148:		    }
    #####: 1149:		  if (j == state->handCount[i])
        -: 1150:		    {
    #####: 1151:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1152:			{
        -: 1153:			  if (DEBUG)
        -: 1154:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1155:			}	
    #####: 1156:		      break;
        -: 1157:		    }		
    #####: 1158:		}
        -: 1159:					
    #####: 1160:	    }
        -: 1161:				
    #####: 1162:	}				
        -: 1163:
        -: 1164:      //discard played card from hand
    #####: 1165:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1166:
    #####: 1167:      return 0;
        -: 1168:
        -: 1169:		
        -: 1170:    case embargo: 
        -: 1171:      //+2 Coins
    #####: 1172:      state->coins = state->coins + 2;
        -: 1173:			
        -: 1174:      //see if selected pile is in play
    #####: 1175:      if ( state->supplyCount[choice1] == -1 )
        -: 1176:	{
    #####: 1177:	  return -1;
        -: 1178:	}
        -: 1179:			
        -: 1180:      //add embargo token to selected supply pile
    #####: 1181:      state->embargoTokens[choice1]++;
        -: 1182:			
        -: 1183:      //trash card
    #####: 1184:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1185:      return 0;
        -: 1186:		
        -: 1187:    case outpost:
        -: 1188:      //set outpost flag
    #####: 1189:      state->outpostPlayed++;
        -: 1190:			
        -: 1191:      //discard card
    #####: 1192:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1193:      return 0;
        -: 1194:		
        -: 1195:    case salvager:
        -: 1196:      //+1 buy
    #####: 1197:      state->numBuys++;
        -: 1198:			
    #####: 1199:      if (choice1)
        -: 1200:	{
        -: 1201:	  //gain coins equal to trashed card
    #####: 1202:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1203:	  //trash card
    #####: 1204:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1205:	}
        -: 1206:			
        -: 1207:      //discard card
    #####: 1208:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1209:      return 0;
        -: 1210:		
        -: 1211:    case sea_hag:
    #####: 1212:      for (i = 0; i < state->numPlayers; i++){
    #####: 1213:	if (i != currentPlayer){
    #####: 1214:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1215:	  state->discardCount[i]++;
    #####: 1216:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1217:	}
    #####: 1218:      }
    #####: 1219:      return 0;
        -: 1220:		
        -: 1221:    case treasure_map:
        -: 1222:      //search hand for another treasure_map
    #####: 1223:      index = -1;
    #####: 1224:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1225:	{
    #####: 1226:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1227:	    {
    #####: 1228:	      index = i;
    #####: 1229:	      break;
        -: 1230:	    }
    #####: 1231:	}
    #####: 1232:      if (index > -1)
        -: 1233:	{
        -: 1234:	  //trash both treasure cards
    #####: 1235:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1236:	  discardCard(index, currentPlayer, state, 1);
        -: 1237:
        -: 1238:	  //gain 4 Gold cards
    #####: 1239:	  for (i = 0; i < 4; i++)
        -: 1240:	    {
    #####: 1241:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1242:	    }
        -: 1243:				
        -: 1244:	  //return success
    #####: 1245:	  return 1;
        -: 1246:	}
        -: 1247:			
        -: 1248:      //no second treasure_map found in hand
    #####: 1249:      return -1;
        -: 1250:    }
        -: 1251:	
    #####: 1252:  return -1;
      361: 1253:}
        -: 1254:
        -: 1255:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1256:{
        -: 1257:	
        -: 1258:  //if card is not trashed, added to Played pile 
      162: 1259:  if (trashFlag < 1)
        -: 1260:    {
        -: 1261:      //add card to played pile
      162: 1262:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      162: 1263:      state->playedCardCount++;
      162: 1264:    }
        -: 1265:	
        -: 1266:  //set played card to -1
      162: 1267:  state->hand[currentPlayer][handPos] = -1;
        -: 1268:	
        -: 1269:  //remove card from player's hand
      162: 1270:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1271:    {
        -: 1272:      //reduce number of cards in hand
    #####: 1273:      state->handCount[currentPlayer]--;
    #####: 1274:    }
      162: 1275:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1276:    {
        -: 1277:      //reduce number of cards in hand
    #####: 1278:      state->handCount[currentPlayer]--;
    #####: 1279:    }
        -: 1280:  else 	
        -: 1281:    {
        -: 1282:      //replace discarded card with last card in hand
      162: 1283:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1284:      //set last card to -1
      162: 1285:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1286:      //reduce number of cards in hand
      162: 1287:      state->handCount[currentPlayer]--;
        -: 1288:    }
        -: 1289:	
      162: 1290:  return 0;
        -: 1291:}
        -: 1292:
        -: 1293:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1294:{
        -: 1295:  //Note: supplyPos is enum of choosen card
        -: 1296:	
        -: 1297:  //check if supply pile is empty (0) or card is not used in game (-1)
     1301: 1298:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1299:    {
       40: 1300:      return -1;
        -: 1301:    }
        -: 1302:	
        -: 1303:  //added card for [whoseTurn] current player:
        -: 1304:  // toFlag = 0 : add to discard
        -: 1305:  // toFlag = 1 : add to deck
        -: 1306:  // toFlag = 2 : add to hand
        -: 1307:
     1261: 1308:  if (toFlag == 1)
        -: 1309:    {
       27: 1310:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
       27: 1311:      state->deckCount[player]++;
       27: 1312:    }
     1234: 1313:  else if (toFlag == 2)
        -: 1314:    {
       41: 1315:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
       41: 1316:      state->handCount[player]++;
       41: 1317:    }
        -: 1318:  else
        -: 1319:    {
     1193: 1320:      state->discard[player][ state->discardCount[player] ] = supplyPos;
     1193: 1321:      state->discardCount[player]++;
        -: 1322:    }
        -: 1323:	
        -: 1324:  //decrease number in supply pile
     1261: 1325:  state->supplyCount[supplyPos]--;
        -: 1326:	 
     1261: 1327:  return 0;
     1301: 1328:}
        -: 1329:
        -: 1330:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1331:{
        -: 1332:  int i;
        -: 1333:	
        -: 1334:  //reset coin count
     1861: 1335:  state->coins = 0;
        -: 1336:
        -: 1337:  //add coins for each Treasure card in player's hand
    22542: 1338:  for (i = 0; i < state->handCount[player]; i++)
        -: 1339:    {
     9410: 1340:      if (state->hand[player][i] == copper)
        -: 1341:	{
     4457: 1342:	  state->coins += 1;
     4457: 1343:	}
     4953: 1344:      else if (state->hand[player][i] == silver)
        -: 1345:	{
     1835: 1346:	  state->coins += 2;
     1835: 1347:	}
     3118: 1348:      else if (state->hand[player][i] == gold)
        -: 1349:	{
      605: 1350:	  state->coins += 3;
      605: 1351:	}	
     9410: 1352:    }	
        -: 1353:
        -: 1354:  //add bonus
     1861: 1355:  state->coins += bonus;
        -: 1356:
     1861: 1357:  return 0;
        -: 1358:}
        -: 1359:
        -: 1360:
        -: 1361://end of dominion.c
        -: 1362:
cardtest3.c:
Starting tests for councilRoomEffect()...

TEST: Player 0 gains 4 cards
Actual: 9
Expected: 8
FAILED

TEST: Player 0 gains 4 cards from his own pile
Actual: 0
Expected: 1
FAILED

TEST: Player 0 number of buys increments
Actual: 2
Expected: 2
PASSED

TEST: No change to victory card piles
Province Pile
Actual: 8
Expected: 8
PASSED

Duchy Pile
Actual: 8
Expected: 8
PASSED

Estate Pile
Actual: 8
Expected: 8
PASSED

TEST: No change to kingdom card piles
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED

TEST: Player 1 gains a card
Actual: 0
Expected: 1
FAILED

TEST: Player 1 gains a card from his own deck
Actual: 10
Expected: 9
FAILED

TEST(S) FAILED
4 of 18 tests failed!
File 'cardtest3.c'
Lines executed:98.48% of 66
cardtest3.c:creating 'cardtest3.c.gcov'

File 'dominion.c'
Lines executed:52.59% of 656
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:260
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    23963:    9:  if (*(int*)a > *(int*)b)
     4441:   10:    return 1;
    19522:   11:  if (*(int*)a < *(int*)b)
     8204:   12:    return -1;
    11318:   13:  return 0;
    23963:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      289:   44:  SelectStream(1);
      289:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
      578:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      289:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     6358:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    63580:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    54910:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    28900:   65:        }
     2890:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      289:   73:  if (numPlayers == 2)
        -:   74:    {
      289:   75:      state->supplyCount[curse] = 10;
      289:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      289:   87:  if (numPlayers == 2)
        -:   88:    {
      289:   89:      state->supplyCount[estate] = 8;
      289:   90:      state->supplyCount[duchy] = 8;
      289:   91:      state->supplyCount[province] = 8;
      289:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      289:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      289:  102:  state->supplyCount[silver] = 40;
      289:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    12138:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    95370:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    44795:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     5524:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
      545:  115:		  if (numPlayers == 2){ 
      545:  116:		    state->supplyCount[i] = 8; 
      545:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
      545:  119:		}
        -:  120:	      else
        -:  121:		{
     2345:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     2890:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    41905:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    41905:  130:	}
        -:  131:
     5780:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     1734:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
      578:  140:      state->deckCount[i] = 0;
     4624:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
     1734:  143:	  state->deck[i][j] = estate;
     1734:  144:	  state->deckCount[i]++;
     1734:  145:	}
     9248:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
     4046:  148:	  state->deck[i][j] = copper;
     4046:  149:	  state->deckCount[i]++;		
     4046:  150:	}
      578:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     1734:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
      578:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
      578:  160:    }
        -:  161:
        -:  162:  //draw player hands
     1734:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      578:  166:      state->handCount[i] = 0;
      578:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
      578:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    16184:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
     7803:  178:      state->embargoTokens[i] = 0;
     7803:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      289:  182:  state->outpostPlayed = 0;
      289:  183:  state->phase = 0;
      289:  184:  state->numActions = 1;
      289:  185:  state->numBuys = 1;
      289:  186:  state->playedCardCount = 0;
      289:  187:  state->whoseTurn = 0;
      289:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     3468:  192:  for (it = 0; it < 5; it++){
     1445:  193:    drawCard(state->whoseTurn, state);
     1445:  194:  }
        -:  195:
      289:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
      289:  198:  return 0;
      289:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     1153:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     1153:  209:  if (state->deckCount[player] < 1)
       72:  210:    return -1;
     1081:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    28734:  214:  while (state->deckCount[player] > 0) {
    13286:  215:    card = floor(Random() * state->deckCount[player]);
    13286:  216:    newDeck[newDeckPos] = state->deck[player][card];
    13286:  217:    newDeckPos++;
   117898:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    45663:  219:      state->deck[player][i] = state->deck[player][i+1];
    45663:  220:    }
    13286:  221:    state->deckCount[player]--;
        -:  222:  }
    28734:  223:  for (i = 0; i < newDeckPos; i++) {
    13286:  224:    state->deck[player][i] = newDeck[i];
    13286:  225:    state->deckCount[player]++;
    13286:  226:  }
        -:  227:
     1081:  228:  return 0;
     1153:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
     1466:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
     1466:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
     1466:  243:  if ( state->numActions < 1 )
        -:  244:    {
     1217:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
      249:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
      494:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
        4:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
      245:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
      245:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
      245:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
      245:  269:  return 0;
     1466:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
     1139:  280:  who = state->whoseTurn;
        -:  281:
     1139:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
     1139:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
     1139:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
     1139:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
     1139:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  298:  
     1139:  299:    state->coins = (state->coins) - (getCost(supplyPos));
     1139:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
     1139:  308:  return 0;
     1139:  309:}
        -:  310:
        -:  311:int numHandCards(struct gameState *state) {
     8955:  312:  return state->handCount[ whoseTurn(state) ];
        -:  313:}
        -:  314:
        -:  315:int handCard(int handPos, struct gameState *state) {
    18023:  316:  int currentPlayer = whoseTurn(state);
    18023:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
        -:  320:int supplyCount(int card, struct gameState *state) {
     2440:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
        -:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
    #####:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
    #####:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
    #####:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
        -:  346:int whoseTurn(struct gameState *state) {
    29652:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
        -:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
     1160:  353:  int currentPlayer = whoseTurn(state);
        -:  354:  
        -:  355:  //Discard hand
    14970:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
     6325:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     6325:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
     6325:  359:  }
     1160:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
     1160:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
      588:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
      588:  365:  }
        -:  366:  else{
      572:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
     1160:  370:  state->outpostPlayed = 0;
     1160:  371:  state->phase = 0;
     1160:  372:  state->numActions = 1;
     1160:  373:  state->coins = 0;
     1160:  374:  state->numBuys = 1;
     1160:  375:  state->playedCardCount = 0;
     1160:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    13920:  380:  for (k = 0; k < 5; k++){
     5800:  381:    drawCard(state->whoseTurn, state);//Draw a card
     5800:  382:  }
        -:  383:
        -:  384:  //Update money
     1160:  385:  updateCoins(state->whoseTurn, state , 0);
        -:  386:
     1160:  387:  return 0;
        -:  388:}
        -:  389:
        -:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
     1318:  395:  if (state->supplyCount[province] == 0)
        -:  396:    {
       74:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
     1244:  401:  j = 0;
    64688:  402:  for (i = 0; i < 25; i++)
        -:  403:    {
    31100:  404:      if (state->supplyCount[i] == 0)
        -:  405:	{
      126:  406:	  j++;
      126:  407:	}
    31100:  408:    }
     1244:  409:  if ( j >= 3)
        -:  410:    {
       42:  411:      return 1;
        -:  412:    }
        -:  413:
     1202:  414:  return 0;
     1318:  415:}
        -:  416:
        -:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
       64:  420:  int score = 0;
        -:  421:  //score from hand
      448:  422:  for (i = 0; i < state->handCount[player]; i++)
        -:  423:    {
      160:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
      180:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
      160:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
      177:  427:      if (state->hand[player][i] == province) { score = score + 6; };
      160:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
      160:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      160:  430:    }
        -:  431:
        -:  432:  //score from discard
     1398:  433:  for (i = 0; i < state->discardCount[player]; i++)
        -:  434:    {
      635:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
      702:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
      635:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
      752:  438:      if (state->discard[player][i] == province) { score = score + 6; };
      635:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
      635:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  441:    }
        -:  442:
        -:  443:  //score from deck
     1398:  444:  for (i = 0; i < state->discardCount[player]; i++)
        -:  445:    {
      670:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
      691:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
      635:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
      719:  449:      if (state->deck[player][i] == province) { score = score + 6; };
      635:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
      635:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  452:    }
        -:  453:
       64:  454:  return score;
        -:  455:}
        -:  456:
        -:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
        -:  468:	{
    #####:  469:	  players[i] = -9999;
    #####:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
        -:  474:	}
    #####:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
        -:  482:	{
    #####:  483:	  j = i;
    #####:  484:	}
    #####:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
        -:  493:	{
    #####:  494:	  players[i]++;
    #####:  495:	}
    #####:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
        -:  503:	{
    #####:  504:	  j = i;
    #####:  505:	}
    #####:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
        -:  513:	{
    #####:  514:	  players[i] = 1;
    #####:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
    #####:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
        -:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     8255:  528:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    14786:  533:    for (i = 0; i < state->discardCount[player];i++){
     6946:  534:      state->deck[player][i] = state->discard[player][i];
     6946:  535:      state->discard[player][i] = -1;
     6946:  536:    }
        -:  537:
      447:  538:    state->deckCount[player] = state->discardCount[player];
      447:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
      447:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
      447:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
      447:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
      447:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
      447:  559:    if (deckCounter == 0)
    #####:  560:      return -1;
        -:  561:
      447:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      447:  563:    state->deckCount[player]--;
      447:  564:    state->handCount[player]++;//Increment hand count
      447:  565:  }
        -:  566:
        -:  567:  else{
     7808:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     7808:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     7808:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     7808:  576:    state->deckCount[player]--;
     7808:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     8255:  580:  return 0;
     8255:  581:}
        -:  582:
        -:  583:int getCost(int cardNumber)
        -:  584:{
     2306:  585:  switch( cardNumber ) 
        -:  586:    {
        -:  587:    case curse:
       10:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
      512:  594:      return 8;
        -:  595:    case copper:
       14:  596:      return 0;
        -:  597:    case silver:
      888:  598:      return 3;
        -:  599:    case gold:
      626:  600:      return 6;
        -:  601:    case adventurer:
      128:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
      128:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
     2306:  644:}
        -:  645:
        -:  646:
        -:  647:void adventurerEffect(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand[], int z)
        -:  648:{
     1654:  649:  while(drawntreasure<=2){
      614:  650:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
       30:  651:	  shuffle(currentPlayer, state);
       30:  652:	}
      614:  653:	drawCard(currentPlayer, state);
      614:  654:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     1077:  655:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
      497:  656:	  drawntreasure++;
        -:  657:	else{
      117:  658:	  temphand[z]=cardDrawn;
      117:  659:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
      117:  660:	  z++;
        -:  661:	}
        -:  662:      }
      660:  663:      while(z-1>=0){
      117:  664:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
      117:  665:	z=z-1;
        -:  666:      }
      213:  667:}
        -:  668:
        -:  669:void smithyEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  670:{
        -:  671:  //+3 Cards
      678:  672:      for (int i = 1; i < 3; i++)
        -:  673:	{
      246:  674:	  drawCard(currentPlayer, state);
      246:  675:	}
        -:  676:			
        -:  677:      //discard card from hand
       93:  678:      discardCard(handPos, currentPlayer, state, 0);
       93:  679:}
        -:  680:
        -:  681:void councilRoomEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  682:{
        -:  683:  //+4 Cards
      270:  684:      for (int i = 0; i < 4; i++)
        -:  685:	{
      108:  686:	  drawCard(currentPlayer, state);
      108:  687:	}
        -:  688:			
        -:  689:      //+1 Buy
       27:  690:      state->numBuys++;
        -:  691:			
        -:  692:      //Each other player draws a card
      162:  693:      for (int i = 0; i < state->numPlayers; i++)
        -:  694:	{
       54:  695:	  if ( i == currentPlayer )
        -:  696:	    {
       27:  697:	      drawCard(i, state);
       27:  698:	    }
       54:  699:	}
        -:  700:			
        -:  701:      //put played card in played card pile
       27:  702:      discardCard(handPos, currentPlayer, state, 0);
       27:  703:}
        -:  704:
        -:  705:void feastEffect(struct gameState *state, int currentPlayer, int temphand[], int choice1, int x)
        -:  706:{
        -:  707:  //gain card with cost up to 5
        -:  708:      //Backup hand
    #####:  709:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  710:	      temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  711:	      state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  712:      }
        -:  713:      //Backup hand
        -:  714:
        -:  715:      //Update Coins for Buy
    #####:  716:      updateCoins(currentPlayer, state, 5);
    #####:  717:      x = 1;//Condition to loop on
    #####:  718:      while( x == 1) {//Buy one card
    #####:  719:	      if (supplyCount(choice1, state) <= 0){
        -:  720:	        if (DEBUG)
        -:  721:	          printf("None of that card left, sorry!\n");
        -:  722:
        -:  723:	        if (DEBUG){
        -:  724:	          printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  725:	        }
    #####:  726:	      }
    #####:  727:	      else if (state->coins < getCost(choice1)){
    #####:  728:	        printf("That card is too expensive!\n");
        -:  729:
        -:  730:	        if (DEBUG){
        -:  731:	          printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  732:	        }
    #####:  733:	      }
        -:  734:	      else{
        -:  735:
        -:  736:	        if (DEBUG){
        -:  737:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  738:	        }
        -:  739:
    #####:  740:	        gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  741:	        x = 0;//No more buying cards
        -:  742:
        -:  743:	        if (DEBUG){
        -:  744:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  745:	        }
        -:  746:
        -:  747:	      }
        -:  748:      }     
        -:  749:
        -:  750:      //Reset Hand
    #####:  751:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  752:	      state->hand[currentPlayer][i] = temphand[i];
    #####:  753:	      temphand[i] = -1;
    #####:  754:      }
    #####:  755:}
        -:  756:
        -:  757:int mineEffect(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int j)
        -:  758:{
       14:  759:  int result = 0;
       14:  760:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  761:
       28:  762:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  763:	    {
    #####:  764:        result = -1;
        -:  765:	      //return -1;
    #####:  766:	    }
        -:  767:		
       28:  768:      if (choice2 > treasure_map || choice2 < curse)
        -:  769:	    {
    #####:  770:        result = -1;
        -:  771:	      //return -1;
    #####:  772:	    }
        -:  773:
       14:  774:      if ( (getCost(state->hand[currentPlayer][choice1]) + 4) > getCost(choice2) )
        -:  775:	    {
       14:  776:        result = -1;
        -:  777:	      //return -1;
       14:  778:	    }
        -:  779:
       14:  780:      gainCard(choice2, state, 2, currentPlayer);
        -:  781:
        -:  782:      //discard card from hand
       14:  783:      discardCard(handPos, currentPlayer, state, 0);
        -:  784:
        -:  785:      //discard trashed card
       56:  786:      for (int i = 0; i < state->handCount[currentPlayer]; i++)
        -:  787:	    {
       28:  788:	      if (state->hand[currentPlayer][i] == j)
        -:  789:	      {
       14:  790:	        discardCard(i, currentPlayer, state, 0);			
       14:  791:	        break;
        -:  792:	      }
       14:  793:	    }
        -:  794:			
       14:  795:      return result;
        -:  796:}
        -:  797:
        -:  798:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  799:{
        -:  800:  int i;
14397326483292946561:  801:  int j = 0;
        -:  802:  int k;
14397326483292946561:  803:  int x = 0;
        -:  804:  int index;
        -:  805:  int result;
14397326483292946561:  806:  int currentPlayer = whoseTurn(state);
14397326483292946561:  807:  int nextPlayer = currentPlayer + 1;
        -:  808:
14397326483292946561:  809:  int tributeRevealedCards[2] = {-1, -1};
        -:  810:  int temphand[MAX_HAND];// moved above the if statement
14397326483292946561:  811:  int drawntreasure=0;
14397326483292946561:  812:  int cardDrawn=0;
14397326483292946561:  813:  int z = 0;// this is the counter for the temp hand
14397326483292946561:  814:  if (nextPlayer > (state->numPlayers - 1)){
  6582881:  815:    nextPlayer = 0;
  6582881:  816:  }
        -:  817:  
        -:  818:	
        -:  819:  //uses switch to select card and perform actions
3352292577943071124:  820:  switch( card ) 
        -:  821:    {
        -:  822:    case adventurer:
474366694533:  823:      adventurerEffect(drawntreasure, state, currentPlayer, cardDrawn, temphand, z);
474366694533:  824:      return 0;
        -:  825:			
        -:  826:    case council_room:
72057594037927963:  827:      councilRoomEffect(state, currentPlayer, handPos);
72057594037927963:  828:      return 0;
        -:  829:			
        -:  830:    case feast:
68719476743:  831:      feastEffect(state, currentPlayer, temphand, choice1,x);
68719476743:  832:      return 0;
        -:  833:			
        -:  834:    case gardens:
17424526879:  835:      return -1;
        -:  836:			
        -:  837:    case mine:
7738139929303872884:  838:      result = mineEffect(state, currentPlayer, choice1, choice2, handPos, j);
7738139929303872884:  839:      return result;
        -:  840:			
        -:  841:    case remodel:
72058094107324227:  842:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  843:
72058094107324227:  844:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  845:	{
73014444037:  846:	  return -1;
        -:  847:	}
        -:  848:
9172086132:  849:      gainCard(choice2, state, 0, currentPlayer);
        -:  850:
        -:  851:      //discard card from hand
9172086132:  852:      discardCard(handPos, currentPlayer, state, 0);
        -:  853:
        -:  854:      //discard trashed card
103145724687375321:  855:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  856:	{
93224767193:  857:	  if (state->hand[currentPlayer][i] == j)
        -:  858:	    {
8525144140093551465:  859:	      discardCard(i, currentPlayer, state, 0);			
8525144140093551465:  860:	      break;
        -:  861:	    }
    29285:  862:	}
        -:  863:
        -:  864:
6217793866309828627:  865:      return 0;
        -:  866:		
        -:  867:    case smithy:
8245918788311056416:  868:      smithyEffect(state, currentPlayer, handPos);
8245918788311056416:  869:      return 0;
        -:  870:		
        -:  871:    case village:
        -:  872:      //+1 Card
1919895156:  873:      drawCard(currentPlayer, state);
        -:  874:			
        -:  875:      //+2 Actions
1919895156:  876:      state->numActions = state->numActions + 2;
        -:  877:			
        -:  878:      //discard played card from hand
1919895156:  879:      discardCard(handPos, currentPlayer, state, 0);
1919895156:  880:      return 0;
        -:  881:		
        -:  882:    case baron:
72057679937273862:  883:      state->numBuys++;//Increase buys by 1!
72057679937273862:  884:      if (choice1 > 0){//Boolean true or going to discard an estate
16919086439:  885:	int p = 0;//Iterator for hand!
16919086439:  886:	int card_not_discarded = 1;//Flag for discard set!
7308900660905877056:  887:	while(card_not_discarded){
14700501649139433493:  888:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
7166187310294237187:  889:	    state->coins += 4;//Add 4 coins to the amount of coins
7166187310294237187:  890:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
7166187310294237187:  891:	    state->discardCount[currentPlayer]++;
7194460570033353316:  892:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  893:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  894:	    }
    #####:  895:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  896:	    state->handCount[currentPlayer]--;
    #####:  897:	    card_not_discarded = 0;//Exit the loop
    #####:  898:	  }
    #####:  899:	  else if (p > state->handCount[currentPlayer]){
        -:  900:	    if(DEBUG) {
        -:  901:	      printf("No estate cards in your hand, invalid choice\n");
        -:  902:	      printf("Must gain an estate if there are any\n");
        -:  903:	    }
    #####:  904:	    if (supplyCount(estate, state) > 0){
    #####:  905:	      gainCard(estate, state, 0, currentPlayer);
    #####:  906:	      state->supplyCount[estate]--;//Decrement estates
    #####:  907:	      if (supplyCount(estate, state) == 0){
    #####:  908:		isGameOver(state);
    #####:  909:	      }
    #####:  910:	    }
    #####:  911:	    card_not_discarded = 0;//Exit the loop
    #####:  912:	  }
        -:  913:			    
        -:  914:	  else{
    #####:  915:	    p++;//Next card
        -:  916:	  }
        -:  917:	}
    #####:  918:      }
        -:  919:			    
        -:  920:      else{
    #####:  921:	if (supplyCount(estate, state) > 0){
    #####:  922:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  923:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  924:	  if (supplyCount(estate, state) == 0){
    #####:  925:	    isGameOver(state);
    #####:  926:	  }
    #####:  927:	}
        -:  928:      }
        -:  929:	    
        -:  930:      
    #####:  931:      return 0;
        -:  932:		
        -:  933:    case great_hall:
        -:  934:      //+1 Card
    #####:  935:      drawCard(currentPlayer, state);
        -:  936:			
        -:  937:      //+1 Actions
    #####:  938:      state->numActions++;
        -:  939:			
        -:  940:      //discard card from hand
    #####:  941:      discardCard(handPos, currentPlayer, state, 0);
    #####:  942:      return 0;
        -:  943:		
        -:  944:    case minion:
        -:  945:      //+1 action
    #####:  946:      state->numActions++;
        -:  947:			
        -:  948:      //discard card from hand
    #####:  949:      discardCard(handPos, currentPlayer, state, 0);
        -:  950:			
    #####:  951:      if (choice1)		//+2 coins
        -:  952:	{
    #####:  953:	  state->coins = state->coins + 2;
    #####:  954:	}
        -:  955:			
    #####:  956:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  957:	{
        -:  958:	  //discard hand
    #####:  959:	  while(numHandCards(state) > 0)
        -:  960:	    {
    #####:  961:	      discardCard(handPos, currentPlayer, state, 0);
        -:  962:	    }
        -:  963:				
        -:  964:	  //draw 4
    #####:  965:	  for (i = 0; i < 4; i++)
        -:  966:	    {
    #####:  967:	      drawCard(currentPlayer, state);
    #####:  968:	    }
        -:  969:				
        -:  970:	  //other players discard hand and redraw if hand size > 4
    #####:  971:	  for (i = 0; i < state->numPlayers; i++)
        -:  972:	    {
    #####:  973:	      if (i != currentPlayer)
        -:  974:		{
    #####:  975:		  if ( state->handCount[i] > 4 )
        -:  976:		    {
        -:  977:		      //discard hand
    #####:  978:		      while( state->handCount[i] > 0 )
        -:  979:			{
    #####:  980:			  discardCard(handPos, i, state, 0);
        -:  981:			}
        -:  982:							
        -:  983:		      //draw 4
    #####:  984:		      for (j = 0; j < 4; j++)
        -:  985:			{
    #####:  986:			  drawCard(i, state);
    #####:  987:			}
    #####:  988:		    }
    #####:  989:		}
    #####:  990:	    }
        -:  991:				
    #####:  992:	}
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case steward:
    #####:  996:      if (choice1 == 1)
        -:  997:	{
        -:  998:	  //+2 cards
    #####:  999:	  drawCard(currentPlayer, state);
    #####: 1000:	  drawCard(currentPlayer, state);
    #####: 1001:	}
    #####: 1002:      else if (choice1 == 2)
        -: 1003:	{
        -: 1004:	  //+2 coins
    #####: 1005:	  state->coins = state->coins + 2;
    #####: 1006:	}
        -: 1007:      else
        -: 1008:	{
        -: 1009:	  //trash 2 cards in hand
    #####: 1010:	  discardCard(choice2, currentPlayer, state, 1);
    #####: 1011:	  discardCard(choice3, currentPlayer, state, 1);
        -: 1012:	}
        -: 1013:			
        -: 1014:      //discard card from hand
    #####: 1015:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1016:      return 0;
        -: 1017:		
        -: 1018:    case tribute:
    #####: 1019:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1020:	if (state->deckCount[nextPlayer] > 0){
    #####: 1021:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1022:	  state->deckCount[nextPlayer]--;
    #####: 1023:	}
    #####: 1024:	else if (state->discardCount[nextPlayer] > 0){
    #####: 1025:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1026:	  state->discardCount[nextPlayer]--;
    #####: 1027:	}
        -: 1028:	else{
        -: 1029:	  //No Card to Reveal
        -: 1030:	  if (DEBUG){
        -: 1031:	    printf("No cards to reveal\n");
        -: 1032:	  }
        -: 1033:	}
    #####: 1034:      }
        -: 1035:	    
        -: 1036:      else{
    #####: 1037:	if (state->deckCount[nextPlayer] == 0){
    #####: 1038:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1039:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1040:	    state->deckCount[nextPlayer]++;
    #####: 1041:	    state->discard[nextPlayer][i] = -1;
    #####: 1042:	    state->discardCount[nextPlayer]--;
    #####: 1043:	  }
        -: 1044:			    
    #####: 1045:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####: 1046:	} 
    #####: 1047:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1048:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1049:	state->deckCount[nextPlayer]--;
    #####: 1050:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
        -: 1053:      }    
        -: 1054:		       
    #####: 1055:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1056:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1057:	state->playedCardCount++;
    #####: 1058:	tributeRevealedCards[1] = -1;
    #####: 1059:      }
        -: 1060:
    #####: 1061:      for (i = 0; i <= 2; i ++){
    #####: 1062:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1063:	  state->coins += 2;
    #####: 1064:	}
        -: 1065:		    
    #####: 1066:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1067:	  drawCard(currentPlayer, state);
    #####: 1068:	  drawCard(currentPlayer, state);
    #####: 1069:	}
        -: 1070:	else{//Action Card
    #####: 1071:	  state->numActions = state->numActions + 2;
        -: 1072:	}
    #####: 1073:      }
        -: 1074:	    
    #####: 1075:      return 0;
        -: 1076:		
        -: 1077:    case ambassador:
    #####: 1078:      j = 0;		//used to check if player has enough cards to discard
        -: 1079:
    #####: 1080:      if (choice2 > 2 || choice2 < 0)
        -: 1081:	{
    #####: 1082:	  return -1;				
        -: 1083:	}
        -: 1084:
    #####: 1085:      if (choice1 == handPos)
        -: 1086:	{
    #####: 1087:	  return -1;
        -: 1088:	}
        -: 1089:
    #####: 1090:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1091:	{
    #####: 1092:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1093:	    {
    #####: 1094:	      j++;
    #####: 1095:	    }
    #####: 1096:	}
    #####: 1097:      if (j < choice2)
        -: 1098:	{
    #####: 1099:	  return -1;				
        -: 1100:	}
        -: 1101:
        -: 1102:      if (DEBUG) 
        -: 1103:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1104:
        -: 1105:      //increase supply count for choosen card by amount being discarded
    #####: 1106:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1107:			
        -: 1108:      //each other player gains a copy of revealed card
    #####: 1109:      for (i = 0; i < state->numPlayers; i++)
        -: 1110:	{
    #####: 1111:	  if (i != currentPlayer)
        -: 1112:	    {
    #####: 1113:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1114:	    }
    #####: 1115:	}
        -: 1116:
        -: 1117:      //discard played card from hand
    #####: 1118:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1119:
        -: 1120:      //trash copies of cards returned to supply
    #####: 1121:      for (j = 0; j < choice2; j++)
        -: 1122:	{
    #####: 1123:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1124:	    {
    #####: 1125:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1126:		{
    #####: 1127:		  discardCard(i, currentPlayer, state, 1);
    #####: 1128:		  break;
        -: 1129:		}
    #####: 1130:	    }
    #####: 1131:	}			
        -: 1132:
    #####: 1133:      return 0;
        -: 1134:		
        -: 1135:    case cutpurse:
        -: 1136:
    #####: 1137:      updateCoins(currentPlayer, state, 2);
    #####: 1138:      for (i = 0; i < state->numPlayers; i++)
        -: 1139:	{
    #####: 1140:	  if (i != currentPlayer)
        -: 1141:	    {
    #####: 1142:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1143:		{
    #####: 1144:		  if (state->hand[i][j] == copper)
        -: 1145:		    {
    #####: 1146:		      discardCard(j, i, state, 0);
    #####: 1147:		      break;
        -: 1148:		    }
    #####: 1149:		  if (j == state->handCount[i])
        -: 1150:		    {
    #####: 1151:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1152:			{
        -: 1153:			  if (DEBUG)
        -: 1154:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1155:			}	
    #####: 1156:		      break;
        -: 1157:		    }		
    #####: 1158:		}
        -: 1159:					
    #####: 1160:	    }
        -: 1161:				
    #####: 1162:	}				
        -: 1163:
        -: 1164:      //discard played card from hand
    #####: 1165:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1166:
    #####: 1167:      return 0;
        -: 1168:
        -: 1169:		
        -: 1170:    case embargo: 
        -: 1171:      //+2 Coins
    #####: 1172:      state->coins = state->coins + 2;
        -: 1173:			
        -: 1174:      //see if selected pile is in play
    #####: 1175:      if ( state->supplyCount[choice1] == -1 )
        -: 1176:	{
    #####: 1177:	  return -1;
        -: 1178:	}
        -: 1179:			
        -: 1180:      //add embargo token to selected supply pile
    #####: 1181:      state->embargoTokens[choice1]++;
        -: 1182:			
        -: 1183:      //trash card
    #####: 1184:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1185:      return 0;
        -: 1186:		
        -: 1187:    case outpost:
        -: 1188:      //set outpost flag
    #####: 1189:      state->outpostPlayed++;
        -: 1190:			
        -: 1191:      //discard card
    #####: 1192:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1193:      return 0;
        -: 1194:		
        -: 1195:    case salvager:
        -: 1196:      //+1 buy
    #####: 1197:      state->numBuys++;
        -: 1198:			
    #####: 1199:      if (choice1)
        -: 1200:	{
        -: 1201:	  //gain coins equal to trashed card
    #####: 1202:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1203:	  //trash card
    #####: 1204:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1205:	}
        -: 1206:			
        -: 1207:      //discard card
    #####: 1208:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1209:      return 0;
        -: 1210:		
        -: 1211:    case sea_hag:
    #####: 1212:      for (i = 0; i < state->numPlayers; i++){
    #####: 1213:	if (i != currentPlayer){
    #####: 1214:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1215:	  state->discardCount[i]++;
    #####: 1216:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1217:	}
    #####: 1218:      }
    #####: 1219:      return 0;
        -: 1220:		
        -: 1221:    case treasure_map:
        -: 1222:      //search hand for another treasure_map
    #####: 1223:      index = -1;
    #####: 1224:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1225:	{
    #####: 1226:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1227:	    {
    #####: 1228:	      index = i;
    #####: 1229:	      break;
        -: 1230:	    }
    #####: 1231:	}
    #####: 1232:      if (index > -1)
        -: 1233:	{
        -: 1234:	  //trash both treasure cards
    #####: 1235:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1236:	  discardCard(index, currentPlayer, state, 1);
        -: 1237:
        -: 1238:	  //gain 4 Gold cards
    #####: 1239:	  for (i = 0; i < 4; i++)
        -: 1240:	    {
    #####: 1241:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1242:	    }
        -: 1243:				
        -: 1244:	  //return success
    #####: 1245:	  return 1;
        -: 1246:	}
        -: 1247:			
        -: 1248:      //no second treasure_map found in hand
    #####: 1249:      return -1;
        -: 1250:    }
        -: 1251:	
    #####: 1252:  return -1;
      362: 1253:}
        -: 1254:
        -: 1255:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1256:{
        -: 1257:	
        -: 1258:  //if card is not trashed, added to Played pile 
      163: 1259:  if (trashFlag < 1)
        -: 1260:    {
        -: 1261:      //add card to played pile
      163: 1262:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      163: 1263:      state->playedCardCount++;
      163: 1264:    }
        -: 1265:	
        -: 1266:  //set played card to -1
      163: 1267:  state->hand[currentPlayer][handPos] = -1;
        -: 1268:	
        -: 1269:  //remove card from player's hand
      163: 1270:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1271:    {
        -: 1272:      //reduce number of cards in hand
    #####: 1273:      state->handCount[currentPlayer]--;
    #####: 1274:    }
      163: 1275:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1276:    {
        -: 1277:      //reduce number of cards in hand
    #####: 1278:      state->handCount[currentPlayer]--;
    #####: 1279:    }
        -: 1280:  else 	
        -: 1281:    {
        -: 1282:      //replace discarded card with last card in hand
      163: 1283:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1284:      //set last card to -1
      163: 1285:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1286:      //reduce number of cards in hand
      163: 1287:      state->handCount[currentPlayer]--;
        -: 1288:    }
        -: 1289:	
      163: 1290:  return 0;
        -: 1291:}
        -: 1292:
        -: 1293:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1294:{
        -: 1295:  //Note: supplyPos is enum of choosen card
        -: 1296:	
        -: 1297:  //check if supply pile is empty (0) or card is not used in game (-1)
     1301: 1298:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1299:    {
       40: 1300:      return -1;
        -: 1301:    }
        -: 1302:	
        -: 1303:  //added card for [whoseTurn] current player:
        -: 1304:  // toFlag = 0 : add to discard
        -: 1305:  // toFlag = 1 : add to deck
        -: 1306:  // toFlag = 2 : add to hand
        -: 1307:
     1261: 1308:  if (toFlag == 1)
        -: 1309:    {
       27: 1310:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
       27: 1311:      state->deckCount[player]++;
       27: 1312:    }
     1234: 1313:  else if (toFlag == 2)
        -: 1314:    {
       41: 1315:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
       41: 1316:      state->handCount[player]++;
       41: 1317:    }
        -: 1318:  else
        -: 1319:    {
     1193: 1320:      state->discard[player][ state->discardCount[player] ] = supplyPos;
     1193: 1321:      state->discardCount[player]++;
        -: 1322:    }
        -: 1323:	
        -: 1324:  //decrease number in supply pile
     1261: 1325:  state->supplyCount[supplyPos]--;
        -: 1326:	 
     1261: 1327:  return 0;
     1301: 1328:}
        -: 1329:
        -: 1330:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1331:{
        -: 1332:  int i;
        -: 1333:	
        -: 1334:  //reset coin count
     1862: 1335:  state->coins = 0;
        -: 1336:
        -: 1337:  //add coins for each Treasure card in player's hand
    22554: 1338:  for (i = 0; i < state->handCount[player]; i++)
        -: 1339:    {
     9415: 1340:      if (state->hand[player][i] == copper)
        -: 1341:	{
     4461: 1342:	  state->coins += 1;
     4461: 1343:	}
     4954: 1344:      else if (state->hand[player][i] == silver)
        -: 1345:	{
     1835: 1346:	  state->coins += 2;
     1835: 1347:	}
     3119: 1348:      else if (state->hand[player][i] == gold)
        -: 1349:	{
      605: 1350:	  state->coins += 3;
      605: 1351:	}	
     9415: 1352:    }	
        -: 1353:
        -: 1354:  //add bonus
     1862: 1355:  state->coins += bonus;
        -: 1356:
     1862: 1357:  return 0;
        -: 1358:}
        -: 1359:
        -: 1360:
        -: 1361://end of dominion.c
        -: 1362:
cardtest4.c:
Starting tests for mineEffect()...

TEST: Player 0 hand count is unaffected
Actual: 4
Expected: 5
FAILED

TEST: Player 0 deck count is unaffected
Actual: 5
Expected: 5
PASSED

TEST: No change to victory card piles
Province Pile
Actual: 8
Expected: 8
PASSED
Duchy Pile
Actual: 8
Expected: 8
PASSED
Estate Pile
Actual: 8
Expected: 8
PASSED

TEST: Player 1 was not affected
Hand Count
Actual: 0
Expected: 0
PASSED
Deck Count
Actual: 10
Expected: 10
PASSED

TEST: No change to kingdom card piles
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED
checking card piles...
PASSED

TEST(S) FAILED
1 of 17 tests failed!
File 'cardtest4.c'
Lines executed:78.57% of 70
cardtest4.c:creating 'cardtest4.c.gcov'

File 'dominion.c'
Lines executed:52.59% of 656
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:261
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    23991:    9:  if (*(int*)a > *(int*)b)
     4441:   10:    return 1;
    19550:   11:  if (*(int*)a < *(int*)b)
     8214:   12:    return -1;
    11336:   13:  return 0;
    23991:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      290:   44:  SelectStream(1);
      290:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
      580:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      290:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     6380:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    63800:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    55100:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    29000:   65:        }
     2900:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      290:   73:  if (numPlayers == 2)
        -:   74:    {
      290:   75:      state->supplyCount[curse] = 10;
      290:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      290:   87:  if (numPlayers == 2)
        -:   88:    {
      290:   89:      state->supplyCount[estate] = 8;
      290:   90:      state->supplyCount[duchy] = 8;
      290:   91:      state->supplyCount[province] = 8;
      290:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      290:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      290:  102:  state->supplyCount[silver] = 40;
      290:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    12180:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    95700:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    44950:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     5543:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
      547:  115:		  if (numPlayers == 2){ 
      547:  116:		    state->supplyCount[i] = 8; 
      547:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
      547:  119:		}
        -:  120:	      else
        -:  121:		{
     2353:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     2900:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    42050:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    42050:  130:	}
        -:  131:
     5800:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     1740:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
      580:  140:      state->deckCount[i] = 0;
     4640:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
     1740:  143:	  state->deck[i][j] = estate;
     1740:  144:	  state->deckCount[i]++;
     1740:  145:	}
     9280:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
     4060:  148:	  state->deck[i][j] = copper;
     4060:  149:	  state->deckCount[i]++;		
     4060:  150:	}
      580:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     1740:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
      580:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
      580:  160:    }
        -:  161:
        -:  162:  //draw player hands
     1740:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      580:  166:      state->handCount[i] = 0;
      580:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
      580:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    16240:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
     7830:  178:      state->embargoTokens[i] = 0;
     7830:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      290:  182:  state->outpostPlayed = 0;
      290:  183:  state->phase = 0;
      290:  184:  state->numActions = 1;
      290:  185:  state->numBuys = 1;
      290:  186:  state->playedCardCount = 0;
      290:  187:  state->whoseTurn = 0;
      290:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     3480:  192:  for (it = 0; it < 5; it++){
     1450:  193:    drawCard(state->whoseTurn, state);
     1450:  194:  }
        -:  195:
      290:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
      290:  198:  return 0;
      290:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     1155:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     1155:  209:  if (state->deckCount[player] < 1)
       72:  210:    return -1;
     1083:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    28778:  214:  while (state->deckCount[player] > 0) {
    13306:  215:    card = floor(Random() * state->deckCount[player]);
    13306:  216:    newDeck[newDeckPos] = state->deck[player][card];
    13306:  217:    newDeckPos++;
   118050:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    45719:  219:      state->deck[player][i] = state->deck[player][i+1];
    45719:  220:    }
    13306:  221:    state->deckCount[player]--;
        -:  222:  }
    28778:  223:  for (i = 0; i < newDeckPos; i++) {
    13306:  224:    state->deck[player][i] = newDeck[i];
    13306:  225:    state->deckCount[player]++;
    13306:  226:  }
        -:  227:
     1083:  228:  return 0;
     1155:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
     1466:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
     1466:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
     1466:  243:  if ( state->numActions < 1 )
        -:  244:    {
     1217:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
      249:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
      494:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
        4:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
      245:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
      245:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
      245:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
      245:  269:  return 0;
     1466:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
     1139:  280:  who = state->whoseTurn;
        -:  281:
     1139:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
     1139:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
     1139:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
     1139:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
     1139:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  298:  
     1139:  299:    state->coins = (state->coins) - (getCost(supplyPos));
     1139:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
     1139:  308:  return 0;
     1139:  309:}
        -:  310:
        -:  311:int numHandCards(struct gameState *state) {
     8955:  312:  return state->handCount[ whoseTurn(state) ];
        -:  313:}
        -:  314:
        -:  315:int handCard(int handPos, struct gameState *state) {
    18023:  316:  int currentPlayer = whoseTurn(state);
    18023:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
        -:  320:int supplyCount(int card, struct gameState *state) {
     2441:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
        -:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
    #####:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
    #####:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
    #####:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
        -:  346:int whoseTurn(struct gameState *state) {
    29653:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
        -:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
     1160:  353:  int currentPlayer = whoseTurn(state);
        -:  354:  
        -:  355:  //Discard hand
    14970:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
     6325:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     6325:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
     6325:  359:  }
     1160:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
     1160:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
      588:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
      588:  365:  }
        -:  366:  else{
      572:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
     1160:  370:  state->outpostPlayed = 0;
     1160:  371:  state->phase = 0;
     1160:  372:  state->numActions = 1;
     1160:  373:  state->coins = 0;
     1160:  374:  state->numBuys = 1;
     1160:  375:  state->playedCardCount = 0;
     1160:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    13920:  380:  for (k = 0; k < 5; k++){
     5800:  381:    drawCard(state->whoseTurn, state);//Draw a card
     5800:  382:  }
        -:  383:
        -:  384:  //Update money
     1160:  385:  updateCoins(state->whoseTurn, state , 0);
        -:  386:
     1160:  387:  return 0;
        -:  388:}
        -:  389:
        -:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
     1318:  395:  if (state->supplyCount[province] == 0)
        -:  396:    {
       74:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
     1244:  401:  j = 0;
    64688:  402:  for (i = 0; i < 25; i++)
        -:  403:    {
    31100:  404:      if (state->supplyCount[i] == 0)
        -:  405:	{
      126:  406:	  j++;
      126:  407:	}
    31100:  408:    }
     1244:  409:  if ( j >= 3)
        -:  410:    {
       42:  411:      return 1;
        -:  412:    }
        -:  413:
     1202:  414:  return 0;
     1318:  415:}
        -:  416:
        -:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
       64:  420:  int score = 0;
        -:  421:  //score from hand
      448:  422:  for (i = 0; i < state->handCount[player]; i++)
        -:  423:    {
      160:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
      180:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
      160:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
      177:  427:      if (state->hand[player][i] == province) { score = score + 6; };
      160:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
      160:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      160:  430:    }
        -:  431:
        -:  432:  //score from discard
     1398:  433:  for (i = 0; i < state->discardCount[player]; i++)
        -:  434:    {
      635:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
      702:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
      635:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
      752:  438:      if (state->discard[player][i] == province) { score = score + 6; };
      635:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
      635:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  441:    }
        -:  442:
        -:  443:  //score from deck
     1398:  444:  for (i = 0; i < state->discardCount[player]; i++)
        -:  445:    {
      670:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
      691:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
      635:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
      719:  449:      if (state->deck[player][i] == province) { score = score + 6; };
      635:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
      635:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
      635:  452:    }
        -:  453:
       64:  454:  return score;
        -:  455:}
        -:  456:
        -:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
        -:  468:	{
    #####:  469:	  players[i] = -9999;
    #####:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
        -:  474:	}
    #####:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
        -:  482:	{
    #####:  483:	  j = i;
    #####:  484:	}
    #####:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
        -:  493:	{
    #####:  494:	  players[i]++;
    #####:  495:	}
    #####:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
        -:  503:	{
    #####:  504:	  j = i;
    #####:  505:	}
    #####:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
        -:  513:	{
    #####:  514:	  players[i] = 1;
    #####:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
    #####:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
        -:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     8260:  528:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    14786:  533:    for (i = 0; i < state->discardCount[player];i++){
     6946:  534:      state->deck[player][i] = state->discard[player][i];
     6946:  535:      state->discard[player][i] = -1;
     6946:  536:    }
        -:  537:
      447:  538:    state->deckCount[player] = state->discardCount[player];
      447:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
      447:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
      447:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
      447:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
      447:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
      447:  559:    if (deckCounter == 0)
    #####:  560:      return -1;
        -:  561:
      447:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      447:  563:    state->deckCount[player]--;
      447:  564:    state->handCount[player]++;//Increment hand count
      447:  565:  }
        -:  566:
        -:  567:  else{
     7813:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     7813:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     7813:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     7813:  576:    state->deckCount[player]--;
     7813:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     8260:  580:  return 0;
     8260:  581:}
        -:  582:
        -:  583:int getCost(int cardNumber)
        -:  584:{
     2308:  585:  switch( cardNumber ) 
        -:  586:    {
        -:  587:    case curse:
       10:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
      512:  594:      return 8;
        -:  595:    case copper:
       15:  596:      return 0;
        -:  597:    case silver:
      889:  598:      return 3;
        -:  599:    case gold:
      626:  600:      return 6;
        -:  601:    case adventurer:
      128:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
      128:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
     2308:  644:}
        -:  645:
        -:  646:
        -:  647:void adventurerEffect(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand[], int z)
        -:  648:{
     1654:  649:  while(drawntreasure<=2){
      614:  650:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
       30:  651:	  shuffle(currentPlayer, state);
       30:  652:	}
      614:  653:	drawCard(currentPlayer, state);
      614:  654:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     1077:  655:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
      497:  656:	  drawntreasure++;
        -:  657:	else{
      117:  658:	  temphand[z]=cardDrawn;
      117:  659:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
      117:  660:	  z++;
        -:  661:	}
        -:  662:      }
      660:  663:      while(z-1>=0){
      117:  664:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
      117:  665:	z=z-1;
        -:  666:      }
      213:  667:}
        -:  668:
        -:  669:void smithyEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  670:{
        -:  671:  //+3 Cards
      678:  672:      for (int i = 1; i < 3; i++)
        -:  673:	{
      246:  674:	  drawCard(currentPlayer, state);
      246:  675:	}
        -:  676:			
        -:  677:      //discard card from hand
       93:  678:      discardCard(handPos, currentPlayer, state, 0);
       93:  679:}
        -:  680:
        -:  681:void councilRoomEffect(struct gameState *state, int currentPlayer, int handPos)
        -:  682:{
        -:  683:  //+4 Cards
      270:  684:      for (int i = 0; i < 4; i++)
        -:  685:	{
      108:  686:	  drawCard(currentPlayer, state);
      108:  687:	}
        -:  688:			
        -:  689:      //+1 Buy
       27:  690:      state->numBuys++;
        -:  691:			
        -:  692:      //Each other player draws a card
      162:  693:      for (int i = 0; i < state->numPlayers; i++)
        -:  694:	{
       54:  695:	  if ( i == currentPlayer )
        -:  696:	    {
       27:  697:	      drawCard(i, state);
       27:  698:	    }
       54:  699:	}
        -:  700:			
        -:  701:      //put played card in played card pile
       27:  702:      discardCard(handPos, currentPlayer, state, 0);
       27:  703:}
        -:  704:
        -:  705:void feastEffect(struct gameState *state, int currentPlayer, int temphand[], int choice1, int x)
        -:  706:{
        -:  707:  //gain card with cost up to 5
        -:  708:      //Backup hand
    #####:  709:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  710:	      temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  711:	      state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  712:      }
        -:  713:      //Backup hand
        -:  714:
        -:  715:      //Update Coins for Buy
    #####:  716:      updateCoins(currentPlayer, state, 5);
    #####:  717:      x = 1;//Condition to loop on
    #####:  718:      while( x == 1) {//Buy one card
    #####:  719:	      if (supplyCount(choice1, state) <= 0){
        -:  720:	        if (DEBUG)
        -:  721:	          printf("None of that card left, sorry!\n");
        -:  722:
        -:  723:	        if (DEBUG){
        -:  724:	          printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  725:	        }
    #####:  726:	      }
    #####:  727:	      else if (state->coins < getCost(choice1)){
    #####:  728:	        printf("That card is too expensive!\n");
        -:  729:
        -:  730:	        if (DEBUG){
        -:  731:	          printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  732:	        }
    #####:  733:	      }
        -:  734:	      else{
        -:  735:
        -:  736:	        if (DEBUG){
        -:  737:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  738:	        }
        -:  739:
    #####:  740:	        gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  741:	        x = 0;//No more buying cards
        -:  742:
        -:  743:	        if (DEBUG){
        -:  744:	          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  745:	        }
        -:  746:
        -:  747:	      }
        -:  748:      }     
        -:  749:
        -:  750:      //Reset Hand
    #####:  751:      for (int i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  752:	      state->hand[currentPlayer][i] = temphand[i];
    #####:  753:	      temphand[i] = -1;
    #####:  754:      }
    #####:  755:}
        -:  756:
        -:  757:int mineEffect(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int j)
        -:  758:{
       15:  759:  int result = 0;
       15:  760:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  761:
       30:  762:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  763:	    {
    #####:  764:        result = -1;
        -:  765:	      //return -1;
    #####:  766:	    }
        -:  767:		
       30:  768:      if (choice2 > treasure_map || choice2 < curse)
        -:  769:	    {
    #####:  770:        result = -1;
        -:  771:	      //return -1;
    #####:  772:	    }
        -:  773:
       15:  774:      if ( (getCost(state->hand[currentPlayer][choice1]) + 4) > getCost(choice2) )
        -:  775:	    {
       15:  776:        result = -1;
        -:  777:	      //return -1;
       15:  778:	    }
        -:  779:
       15:  780:      gainCard(choice2, state, 2, currentPlayer);
        -:  781:
        -:  782:      //discard card from hand
       15:  783:      discardCard(handPos, currentPlayer, state, 0);
        -:  784:
        -:  785:      //discard trashed card
       60:  786:      for (int i = 0; i < state->handCount[currentPlayer]; i++)
        -:  787:	    {
       30:  788:	      if (state->hand[currentPlayer][i] == j)
        -:  789:	      {
       15:  790:	        discardCard(i, currentPlayer, state, 0);			
       15:  791:	        break;
        -:  792:	      }
       15:  793:	    }
        -:  794:			
       15:  795:      return result;
        -:  796:}
        -:  797:
        -:  798:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  799:{
        -:  800:  int i;
14397326483292946562:  801:  int j = 0;
        -:  802:  int k;
14397326483292946562:  803:  int x = 0;
        -:  804:  int index;
        -:  805:  int result;
14397326483292946562:  806:  int currentPlayer = whoseTurn(state);
14397326483292946562:  807:  int nextPlayer = currentPlayer + 1;
        -:  808:
14397326483292946562:  809:  int tributeRevealedCards[2] = {-1, -1};
        -:  810:  int temphand[MAX_HAND];// moved above the if statement
14397326483292946562:  811:  int drawntreasure=0;
14397326483292946562:  812:  int cardDrawn=0;
14397326483292946562:  813:  int z = 0;// this is the counter for the temp hand
14397326483292946562:  814:  if (nextPlayer > (state->numPlayers - 1)){
  6582881:  815:    nextPlayer = 0;
  6582881:  816:  }
        -:  817:  
        -:  818:	
        -:  819:  //uses switch to select card and perform actions
3352292577943071125:  820:  switch( card ) 
        -:  821:    {
        -:  822:    case adventurer:
474366694533:  823:      adventurerEffect(drawntreasure, state, currentPlayer, cardDrawn, temphand, z);
474366694533:  824:      return 0;
        -:  825:			
        -:  826:    case council_room:
72057594037927963:  827:      councilRoomEffect(state, currentPlayer, handPos);
72057594037927963:  828:      return 0;
        -:  829:			
        -:  830:    case feast:
68719476743:  831:      feastEffect(state, currentPlayer, temphand, choice1,x);
68719476743:  832:      return 0;
        -:  833:			
        -:  834:    case gardens:
17424526879:  835:      return -1;
        -:  836:			
        -:  837:    case mine:
7738139929303872885:  838:      result = mineEffect(state, currentPlayer, choice1, choice2, handPos, j);
7738139929303872885:  839:      return result;
        -:  840:			
        -:  841:    case remodel:
72058094107324227:  842:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  843:
72058094107324227:  844:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  845:	{
73014444037:  846:	  return -1;
        -:  847:	}
        -:  848:
9172086132:  849:      gainCard(choice2, state, 0, currentPlayer);
        -:  850:
        -:  851:      //discard card from hand
9172086132:  852:      discardCard(handPos, currentPlayer, state, 0);
        -:  853:
        -:  854:      //discard trashed card
103145724687375321:  855:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  856:	{
93224767193:  857:	  if (state->hand[currentPlayer][i] == j)
        -:  858:	    {
8525144140093551465:  859:	      discardCard(i, currentPlayer, state, 0);			
8525144140093551465:  860:	      break;
        -:  861:	    }
    29285:  862:	}
        -:  863:
        -:  864:
6217793866309828627:  865:      return 0;
        -:  866:		
        -:  867:    case smithy:
8245918788311056416:  868:      smithyEffect(state, currentPlayer, handPos);
8245918788311056416:  869:      return 0;
        -:  870:		
        -:  871:    case village:
        -:  872:      //+1 Card
1919895156:  873:      drawCard(currentPlayer, state);
        -:  874:			
        -:  875:      //+2 Actions
1919895156:  876:      state->numActions = state->numActions + 2;
        -:  877:			
        -:  878:      //discard played card from hand
1919895156:  879:      discardCard(handPos, currentPlayer, state, 0);
1919895156:  880:      return 0;
        -:  881:		
        -:  882:    case baron:
72057679937273862:  883:      state->numBuys++;//Increase buys by 1!
72057679937273862:  884:      if (choice1 > 0){//Boolean true or going to discard an estate
16919086439:  885:	int p = 0;//Iterator for hand!
16919086439:  886:	int card_not_discarded = 1;//Flag for discard set!
7308900660905877056:  887:	while(card_not_discarded){
14700501649139433493:  888:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
7166187310294237187:  889:	    state->coins += 4;//Add 4 coins to the amount of coins
7166187310294237187:  890:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
7166187310294237187:  891:	    state->discardCount[currentPlayer]++;
7194460570033353316:  892:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  893:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  894:	    }
    #####:  895:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  896:	    state->handCount[currentPlayer]--;
    #####:  897:	    card_not_discarded = 0;//Exit the loop
    #####:  898:	  }
    #####:  899:	  else if (p > state->handCount[currentPlayer]){
        -:  900:	    if(DEBUG) {
        -:  901:	      printf("No estate cards in your hand, invalid choice\n");
        -:  902:	      printf("Must gain an estate if there are any\n");
        -:  903:	    }
    #####:  904:	    if (supplyCount(estate, state) > 0){
    #####:  905:	      gainCard(estate, state, 0, currentPlayer);
    #####:  906:	      state->supplyCount[estate]--;//Decrement estates
    #####:  907:	      if (supplyCount(estate, state) == 0){
    #####:  908:		isGameOver(state);
    #####:  909:	      }
    #####:  910:	    }
    #####:  911:	    card_not_discarded = 0;//Exit the loop
    #####:  912:	  }
        -:  913:			    
        -:  914:	  else{
    #####:  915:	    p++;//Next card
        -:  916:	  }
        -:  917:	}
    #####:  918:      }
        -:  919:			    
        -:  920:      else{
    #####:  921:	if (supplyCount(estate, state) > 0){
    #####:  922:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  923:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  924:	  if (supplyCount(estate, state) == 0){
    #####:  925:	    isGameOver(state);
    #####:  926:	  }
    #####:  927:	}
        -:  928:      }
        -:  929:	    
        -:  930:      
    #####:  931:      return 0;
        -:  932:		
        -:  933:    case great_hall:
        -:  934:      //+1 Card
    #####:  935:      drawCard(currentPlayer, state);
        -:  936:			
        -:  937:      //+1 Actions
    #####:  938:      state->numActions++;
        -:  939:			
        -:  940:      //discard card from hand
    #####:  941:      discardCard(handPos, currentPlayer, state, 0);
    #####:  942:      return 0;
        -:  943:		
        -:  944:    case minion:
        -:  945:      //+1 action
    #####:  946:      state->numActions++;
        -:  947:			
        -:  948:      //discard card from hand
    #####:  949:      discardCard(handPos, currentPlayer, state, 0);
        -:  950:			
    #####:  951:      if (choice1)		//+2 coins
        -:  952:	{
    #####:  953:	  state->coins = state->coins + 2;
    #####:  954:	}
        -:  955:			
    #####:  956:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  957:	{
        -:  958:	  //discard hand
    #####:  959:	  while(numHandCards(state) > 0)
        -:  960:	    {
    #####:  961:	      discardCard(handPos, currentPlayer, state, 0);
        -:  962:	    }
        -:  963:				
        -:  964:	  //draw 4
    #####:  965:	  for (i = 0; i < 4; i++)
        -:  966:	    {
    #####:  967:	      drawCard(currentPlayer, state);
    #####:  968:	    }
        -:  969:				
        -:  970:	  //other players discard hand and redraw if hand size > 4
    #####:  971:	  for (i = 0; i < state->numPlayers; i++)
        -:  972:	    {
    #####:  973:	      if (i != currentPlayer)
        -:  974:		{
    #####:  975:		  if ( state->handCount[i] > 4 )
        -:  976:		    {
        -:  977:		      //discard hand
    #####:  978:		      while( state->handCount[i] > 0 )
        -:  979:			{
    #####:  980:			  discardCard(handPos, i, state, 0);
        -:  981:			}
        -:  982:							
        -:  983:		      //draw 4
    #####:  984:		      for (j = 0; j < 4; j++)
        -:  985:			{
    #####:  986:			  drawCard(i, state);
    #####:  987:			}
    #####:  988:		    }
    #####:  989:		}
    #####:  990:	    }
        -:  991:				
    #####:  992:	}
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case steward:
    #####:  996:      if (choice1 == 1)
        -:  997:	{
        -:  998:	  //+2 cards
    #####:  999:	  drawCard(currentPlayer, state);
    #####: 1000:	  drawCard(currentPlayer, state);
    #####: 1001:	}
    #####: 1002:      else if (choice1 == 2)
        -: 1003:	{
        -: 1004:	  //+2 coins
    #####: 1005:	  state->coins = state->coins + 2;
    #####: 1006:	}
        -: 1007:      else
        -: 1008:	{
        -: 1009:	  //trash 2 cards in hand
    #####: 1010:	  discardCard(choice2, currentPlayer, state, 1);
    #####: 1011:	  discardCard(choice3, currentPlayer, state, 1);
        -: 1012:	}
        -: 1013:			
        -: 1014:      //discard card from hand
    #####: 1015:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1016:      return 0;
        -: 1017:		
        -: 1018:    case tribute:
    #####: 1019:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1020:	if (state->deckCount[nextPlayer] > 0){
    #####: 1021:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1022:	  state->deckCount[nextPlayer]--;
    #####: 1023:	}
    #####: 1024:	else if (state->discardCount[nextPlayer] > 0){
    #####: 1025:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1026:	  state->discardCount[nextPlayer]--;
    #####: 1027:	}
        -: 1028:	else{
        -: 1029:	  //No Card to Reveal
        -: 1030:	  if (DEBUG){
        -: 1031:	    printf("No cards to reveal\n");
        -: 1032:	  }
        -: 1033:	}
    #####: 1034:      }
        -: 1035:	    
        -: 1036:      else{
    #####: 1037:	if (state->deckCount[nextPlayer] == 0){
    #####: 1038:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1039:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1040:	    state->deckCount[nextPlayer]++;
    #####: 1041:	    state->discard[nextPlayer][i] = -1;
    #####: 1042:	    state->discardCount[nextPlayer]--;
    #####: 1043:	  }
        -: 1044:			    
    #####: 1045:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####: 1046:	} 
    #####: 1047:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1048:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1049:	state->deckCount[nextPlayer]--;
    #####: 1050:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
        -: 1053:      }    
        -: 1054:		       
    #####: 1055:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1056:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1057:	state->playedCardCount++;
    #####: 1058:	tributeRevealedCards[1] = -1;
    #####: 1059:      }
        -: 1060:
    #####: 1061:      for (i = 0; i <= 2; i ++){
    #####: 1062:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1063:	  state->coins += 2;
    #####: 1064:	}
        -: 1065:		    
    #####: 1066:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1067:	  drawCard(currentPlayer, state);
    #####: 1068:	  drawCard(currentPlayer, state);
    #####: 1069:	}
        -: 1070:	else{//Action Card
    #####: 1071:	  state->numActions = state->numActions + 2;
        -: 1072:	}
    #####: 1073:      }
        -: 1074:	    
    #####: 1075:      return 0;
        -: 1076:		
        -: 1077:    case ambassador:
    #####: 1078:      j = 0;		//used to check if player has enough cards to discard
        -: 1079:
    #####: 1080:      if (choice2 > 2 || choice2 < 0)
        -: 1081:	{
    #####: 1082:	  return -1;				
        -: 1083:	}
        -: 1084:
    #####: 1085:      if (choice1 == handPos)
        -: 1086:	{
    #####: 1087:	  return -1;
        -: 1088:	}
        -: 1089:
    #####: 1090:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1091:	{
    #####: 1092:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1093:	    {
    #####: 1094:	      j++;
    #####: 1095:	    }
    #####: 1096:	}
    #####: 1097:      if (j < choice2)
        -: 1098:	{
    #####: 1099:	  return -1;				
        -: 1100:	}
        -: 1101:
        -: 1102:      if (DEBUG) 
        -: 1103:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1104:
        -: 1105:      //increase supply count for choosen card by amount being discarded
    #####: 1106:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1107:			
        -: 1108:      //each other player gains a copy of revealed card
    #####: 1109:      for (i = 0; i < state->numPlayers; i++)
        -: 1110:	{
    #####: 1111:	  if (i != currentPlayer)
        -: 1112:	    {
    #####: 1113:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1114:	    }
    #####: 1115:	}
        -: 1116:
        -: 1117:      //discard played card from hand
    #####: 1118:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1119:
        -: 1120:      //trash copies of cards returned to supply
    #####: 1121:      for (j = 0; j < choice2; j++)
        -: 1122:	{
    #####: 1123:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1124:	    {
    #####: 1125:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1126:		{
    #####: 1127:		  discardCard(i, currentPlayer, state, 1);
    #####: 1128:		  break;
        -: 1129:		}
    #####: 1130:	    }
    #####: 1131:	}			
        -: 1132:
    #####: 1133:      return 0;
        -: 1134:		
        -: 1135:    case cutpurse:
        -: 1136:
    #####: 1137:      updateCoins(currentPlayer, state, 2);
    #####: 1138:      for (i = 0; i < state->numPlayers; i++)
        -: 1139:	{
    #####: 1140:	  if (i != currentPlayer)
        -: 1141:	    {
    #####: 1142:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1143:		{
    #####: 1144:		  if (state->hand[i][j] == copper)
        -: 1145:		    {
    #####: 1146:		      discardCard(j, i, state, 0);
    #####: 1147:		      break;
        -: 1148:		    }
    #####: 1149:		  if (j == state->handCount[i])
        -: 1150:		    {
    #####: 1151:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1152:			{
        -: 1153:			  if (DEBUG)
        -: 1154:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1155:			}	
    #####: 1156:		      break;
        -: 1157:		    }		
    #####: 1158:		}
        -: 1159:					
    #####: 1160:	    }
        -: 1161:				
    #####: 1162:	}				
        -: 1163:
        -: 1164:      //discard played card from hand
    #####: 1165:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1166:
    #####: 1167:      return 0;
        -: 1168:
        -: 1169:		
        -: 1170:    case embargo: 
        -: 1171:      //+2 Coins
    #####: 1172:      state->coins = state->coins + 2;
        -: 1173:			
        -: 1174:      //see if selected pile is in play
    #####: 1175:      if ( state->supplyCount[choice1] == -1 )
        -: 1176:	{
    #####: 1177:	  return -1;
        -: 1178:	}
        -: 1179:			
        -: 1180:      //add embargo token to selected supply pile
    #####: 1181:      state->embargoTokens[choice1]++;
        -: 1182:			
        -: 1183:      //trash card
    #####: 1184:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1185:      return 0;
        -: 1186:		
        -: 1187:    case outpost:
        -: 1188:      //set outpost flag
    #####: 1189:      state->outpostPlayed++;
        -: 1190:			
        -: 1191:      //discard card
    #####: 1192:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1193:      return 0;
        -: 1194:		
        -: 1195:    case salvager:
        -: 1196:      //+1 buy
    #####: 1197:      state->numBuys++;
        -: 1198:			
    #####: 1199:      if (choice1)
        -: 1200:	{
        -: 1201:	  //gain coins equal to trashed card
    #####: 1202:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1203:	  //trash card
    #####: 1204:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1205:	}
        -: 1206:			
        -: 1207:      //discard card
    #####: 1208:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1209:      return 0;
        -: 1210:		
        -: 1211:    case sea_hag:
    #####: 1212:      for (i = 0; i < state->numPlayers; i++){
    #####: 1213:	if (i != currentPlayer){
    #####: 1214:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1215:	  state->discardCount[i]++;
    #####: 1216:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1217:	}
    #####: 1218:      }
    #####: 1219:      return 0;
        -: 1220:		
        -: 1221:    case treasure_map:
        -: 1222:      //search hand for another treasure_map
    #####: 1223:      index = -1;
    #####: 1224:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1225:	{
    #####: 1226:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1227:	    {
    #####: 1228:	      index = i;
    #####: 1229:	      break;
        -: 1230:	    }
    #####: 1231:	}
    #####: 1232:      if (index > -1)
        -: 1233:	{
        -: 1234:	  //trash both treasure cards
    #####: 1235:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1236:	  discardCard(index, currentPlayer, state, 1);
        -: 1237:
        -: 1238:	  //gain 4 Gold cards
    #####: 1239:	  for (i = 0; i < 4; i++)
        -: 1240:	    {
    #####: 1241:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1242:	    }
        -: 1243:				
        -: 1244:	  //return success
    #####: 1245:	  return 1;
        -: 1246:	}
        -: 1247:			
        -: 1248:      //no second treasure_map found in hand
    #####: 1249:      return -1;
        -: 1250:    }
        -: 1251:	
    #####: 1252:  return -1;
      363: 1253:}
        -: 1254:
        -: 1255:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1256:{
        -: 1257:	
        -: 1258:  //if card is not trashed, added to Played pile 
      165: 1259:  if (trashFlag < 1)
        -: 1260:    {
        -: 1261:      //add card to played pile
      165: 1262:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      165: 1263:      state->playedCardCount++;
      165: 1264:    }
        -: 1265:	
        -: 1266:  //set played card to -1
      165: 1267:  state->hand[currentPlayer][handPos] = -1;
        -: 1268:	
        -: 1269:  //remove card from player's hand
      165: 1270:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1271:    {
        -: 1272:      //reduce number of cards in hand
    #####: 1273:      state->handCount[currentPlayer]--;
    #####: 1274:    }
      165: 1275:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1276:    {
        -: 1277:      //reduce number of cards in hand
    #####: 1278:      state->handCount[currentPlayer]--;
    #####: 1279:    }
        -: 1280:  else 	
        -: 1281:    {
        -: 1282:      //replace discarded card with last card in hand
      165: 1283:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1284:      //set last card to -1
      165: 1285:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1286:      //reduce number of cards in hand
      165: 1287:      state->handCount[currentPlayer]--;
        -: 1288:    }
        -: 1289:	
      165: 1290:  return 0;
        -: 1291:}
        -: 1292:
        -: 1293:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1294:{
        -: 1295:  //Note: supplyPos is enum of choosen card
        -: 1296:	
        -: 1297:  //check if supply pile is empty (0) or card is not used in game (-1)
     1302: 1298:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1299:    {
       40: 1300:      return -1;
        -: 1301:    }
        -: 1302:	
        -: 1303:  //added card for [whoseTurn] current player:
        -: 1304:  // toFlag = 0 : add to discard
        -: 1305:  // toFlag = 1 : add to deck
        -: 1306:  // toFlag = 2 : add to hand
        -: 1307:
     1262: 1308:  if (toFlag == 1)
        -: 1309:    {
       27: 1310:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
       27: 1311:      state->deckCount[player]++;
       27: 1312:    }
     1235: 1313:  else if (toFlag == 2)
        -: 1314:    {
       42: 1315:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
       42: 1316:      state->handCount[player]++;
       42: 1317:    }
        -: 1318:  else
        -: 1319:    {
     1193: 1320:      state->discard[player][ state->discardCount[player] ] = supplyPos;
     1193: 1321:      state->discardCount[player]++;
        -: 1322:    }
        -: 1323:	
        -: 1324:  //decrease number in supply pile
     1262: 1325:  state->supplyCount[supplyPos]--;
        -: 1326:	 
     1262: 1327:  return 0;
     1302: 1328:}
        -: 1329:
        -: 1330:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1331:{
        -: 1332:  int i;
        -: 1333:	
        -: 1334:  //reset coin count
     1863: 1335:  state->coins = 0;
        -: 1336:
        -: 1337:  //add coins for each Treasure card in player's hand
    22566: 1338:  for (i = 0; i < state->handCount[player]; i++)
        -: 1339:    {
     9420: 1340:      if (state->hand[player][i] == copper)
        -: 1341:	{
     4465: 1342:	  state->coins += 1;
     4465: 1343:	}
     4955: 1344:      else if (state->hand[player][i] == silver)
        -: 1345:	{
     1835: 1346:	  state->coins += 2;
     1835: 1347:	}
     3120: 1348:      else if (state->hand[player][i] == gold)
        -: 1349:	{
      605: 1350:	  state->coins += 3;
      605: 1351:	}	
     9420: 1352:    }	
        -: 1353:
        -: 1354:  //add bonus
     1863: 1355:  state->coins += bonus;
        -: 1356:
     1863: 1357:  return 0;
        -: 1358:}
        -: 1359:
        -: 1360:
        -: 1361://end of dominion.c
        -: 1362:
